<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simple tools for networking / objects in plain C: SOCKET</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simple tools for networking / objects in plain C&#160;<span id="projectnumber">Snapshot</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SOCKET</div>  </div>
</div>
<div class="contents">

<p>a usable socket abstraction  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">tagSOCKCTX</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga3adf1d96e791aba989b3bcd0ff855d44">LINGER_OPTION_VALUE</a>&#160;&#160;&#160;300</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga387cd63d9202db79a473a4312e50a6d0">SOCKCTX_FLAGS_NAGLE_ON</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga4e5ab8d07bf7233fe5358f74f89192d0">SOCKTCX_FLAGS_DONT_CLOSE_ON_PEER_CLOSE</a>&#160;&#160;&#160;4</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00003.html">tagSOCKCTX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga33ae627ac286035a2b486c6ab593d8af">SOCKCTX</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#gaa58093540ffae6b2fd5114af70ea9249">SOCK_init</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx, int verbose, int flags)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a socket and sets some options  <a href="#gaa58093540ffae6b2fd5114af70ea9249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga691ca5d5947940ef7bb8e05f5f4381ee">SOCK_send_buffer_sizes</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx, int read_buffer_size, int write_buffer_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set read and write buffer sizes; a value of -1 for buffer size is ignored.  <a href="#ga691ca5d5947940ef7bb8e05f5f4381ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga9a6c6d2ae46cdab6fe52e285f9a8990d">SOCK_connect</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx, void *addr, int addr_size, int connect_timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">connects a sockets with timeout (in seconds)  <a href="#ga9a6c6d2ae46cdab6fe52e285f9a8990d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga29f9645369f83530169a0009c19ed35c">SOCK_recv</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx, char *msg, size_t length, int read_timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">read some data from a socket with timeout (in seconds)  <a href="#ga29f9645369f83530169a0009c19ed35c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#ga4d44efb92c4cd8cc45d2f7434d0f34bf">SOCK_recv_all</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx, char *msg, size_t length, int read_timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">read whe whole buffer from a socket with timeout (in seconds)  <a href="#ga4d44efb92c4cd8cc45d2f7434d0f34bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#gabbd75054a6005f6da12fa57a9032495a">SOCK_send</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx, void *msg, size_t length, int write_timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">write whe whole buffer from a socket with timeout (in seconds)  <a href="#gabbd75054a6005f6da12fa57a9032495a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#gad78589add776d85bd1c2e25a9d960eef">SOCK_close</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">close the  <a href="#gad78589add776d85bd1c2e25a9d960eef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html#gaa4e7c6427b947269086042413e060ed3">SOCK_close_with_reset</a> (<a class="el" href="a00003.html">SOCKCTX</a> *ctx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ungraceful connection termination.  <a href="#gaa4e7c6427b947269086042413e060ed3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>a usable socket abstraction </p>
<p>When you create a socket(2) then it is blocking by default. This means that you can't specify a timeout while using the socket - that makes it useless for any practical purpose.</p>
<p>This abstraction creates a non blocking socket, and you can use it in a blocking manner from a thread, alas you can specify timeouts. This way you can have 'one thread per connection' in a way that allows you to set timeouts for read, write and connect primitives.</p>
<p>In a way this wrapper replace one set of utterly incomprehensible default behavior (the Berkley socket api) with another set of behaviour (which maybe makes more sense, maybe it doesn't - a matter of taste, as many things are with computers)</p>
<p>Still, the Berkley socket interface is supposed to create the illusion, that one can do TCP networking without understanding the protocols. That is an illusion, and one simply has to read 'TCP IP Illustrated' by R. Stevens in order to correct it. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga3adf1d96e791aba989b3bcd0ff855d44"></a><!-- doxytag: member="sock.h::LINGER_OPTION_VALUE" ref="ga3adf1d96e791aba989b3bcd0ff855d44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINGER_OPTION_VALUE&#160;&#160;&#160;300</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00008_source.html#l00034">34</a> of file <a class="el" href="a00008_source.html">sock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga387cd63d9202db79a473a4312e50a6d0"></a><!-- doxytag: member="sock.h::SOCKCTX_FLAGS_NAGLE_ON" ref="ga387cd63d9202db79a473a4312e50a6d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKCTX_FLAGS_NAGLE_ON&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>if flag is set then nagle algorithm is enabled - this is the opposite behaviour of normal sockets where nagle is enabled by default.</p>
<p>The Nagle algorithm makes sense for high latency networks such as the internet; it does not make sense for low latency LAN networks. Here application performance is typically faster without the nagle algorithm. - this stuff therefore assumes that is more likely used in a local network.</p>
<p>The Nagle algorithm <a href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm">http://en.wikipedia.org/wiki/Nagle%27s_algorithm</a> tries to combine network writes into larger packets, If the application calls send then the data is not Immediately written out; instead it is gathered with the hope of accumulating data into larger packets, these packets are then sent on the Nagle algorithm's timer. </p>

<p>Definition at line <a class="el" href="a00008_source.html#l00046">46</a> of file <a class="el" href="a00008_source.html">sock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e5ab8d07bf7233fe5358f74f89192d0"></a><!-- doxytag: member="sock.h::SOCKTCX_FLAGS_DONT_CLOSE_ON_PEER_CLOSE" ref="ga4e5ab8d07bf7233fe5358f74f89192d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKTCX_FLAGS_DONT_CLOSE_ON_PEER_CLOSE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In 99% of all application protocols you will want to close the connection, once the peer closes it's side, and recv returns 0.</p>
<p>Set this option if you do not want the socket closed, once the peer closes it's side of the connection, and recv returns 0;</p>
<p>Setting this option means the following. Once the peer closes its connection, it is no longer able to send data over the connection, howeve the peer still expects to read outstanding data that will be send by the application, and the application will send this data after it has received the information that the peer closed its side.</p>
<p>Also, if this options is set, then SO_LINGER option is enabled to the value of LINGER_OPTION_VALUE This means that when the socket is closed, and there is data that has to be written still, then close will block until the outstanding data has been acknowledged by the peer. </p>

<p>Definition at line <a class="el" href="a00008_source.html#l00062">62</a> of file <a class="el" href="a00008_source.html">sock.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga33ae627ac286035a2b486c6ab593d8af"></a><!-- doxytag: member="sock.h::SOCKCTX" ref="ga33ae627ac286035a2b486c6ab593d8af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00003.html">tagSOCKCTX</a>  <a class="el" href="a00003.html">SOCKCTX</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad78589add776d85bd1c2e25a9d960eef"></a><!-- doxytag: member="sock.h::SOCK_close" ref="gad78589add776d85bd1c2e25a9d960eef" args="(SOCKCTX *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>close the </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. socket </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00318">318</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a> != -1) {
    <span class="keywordflow">if</span> (close(ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>)) {
      <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
         fprintf(stderr,<span class="stringliteral">&quot;Close failed errno %d\n&quot;</span>, errno);
      }
    }
    ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a> = -1;
    ctx-&gt;<a class="code" href="a00003.html#a5283ea4aa0d2447d230e37074a0589ef">connected</a> = 0;
  }
  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaa4e7c6427b947269086042413e060ed3"></a><!-- doxytag: member="sock.h::SOCK_close_with_reset" ref="gaa4e7c6427b947269086042413e060ed3" args="(SOCKCTX *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_close_with_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ungraceful connection termination. </p>
<p>This function avoids TIME_WAIT when initiating closing of connection.</p>
<p>TIME_WAIT occurs, when the socket has been shut down properly; the application has sent FIN to the peer, and received an ACK for this message; the application has now sent the final last ACK to the peer; the connection is now in TIME_WAIT state and remains so for quite some time. Why? The last ACK might get lost, so TCP wants to make sure that no retransmissions of the last ACK are required.</p>
<p>For high performance servers this can mean that we will run out of socket handles.</p>
<p>The solution is for the client to terminate the connection ungracefully; instead of sending a FIN packet, the application can send out a RST (reset) packet, this will avoid the whole protocol of closing connections.</p>
<p>Here the SO_LINGER option is set with timeout of 0 prior to calling close; this results in sending out the RST packet / terminates the connection ungracefully.</p>
<p>Note that there is still a chance that the RST packet will get lost; in this we can only hope that the server will close it's side of the connection due to some connection idle timeout. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00332">332</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">struct </span>linger l;
  
  l.l_onoff = 1; l.l_linger = 0;

  <span class="keywordflow">if</span> (setsockopt( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, SOL_SOCKET, SO_LINGER, &amp;l, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> linger) )) {
      <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
       fprintf(stderr,<span class="stringliteral">&quot;Failed to set linger option. %d\n&quot;</span>, errno );
      }
  }

  <span class="keywordflow">return</span> <a class="code" href="a00011.html#gad78589add776d85bd1c2e25a9d960eef" title="close the">SOCK_close</a>( ctx );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga9a6c6d2ae46cdab6fe52e285f9a8990d"></a><!-- doxytag: member="sock.h::SOCK_connect" ref="ga9a6c6d2ae46cdab6fe52e285f9a8990d" args="(SOCKCTX *ctx, void *addr, int addr_size, int connect_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>connect_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>connects a sockets with timeout (in seconds) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. </td></tr>
    <tr><td class="paramname">addr</td><td></td></tr>
    <tr><td class="paramname">addr_size</td><td></td></tr>
    <tr><td class="paramname">connect_timeout</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00096">96</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> rt;
  fd_set wset,eset;
  <span class="keyword">struct </span>timeval tv;
  <span class="keywordtype">int</span> error = 0;
  <span class="keywordtype">int</span> len;
    
  <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#a5283ea4aa0d2447d230e37074a0589ef">connected</a>) {
    <span class="keywordflow">return</span> 0;
  }

  <span class="keywordflow">if</span> (addr != 0) {
     ctx-&gt;<a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">addr</a> = malloc( addr_size );
     <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">addr</a>) {
       <span class="keywordflow">goto</span> err;
     }
     memcpy( ctx-&gt;<a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">addr</a>, addr, addr_size );
     ctx-&gt;<a class="code" href="a00003.html#a090065b6dfa838ecdf5ca535d6befa24">addr_size</a> = addr_size;
  }

  <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">addr</a>) {
    <span class="keywordflow">goto</span> err;
  }

  <span class="keywordflow">do</span> {
    rt = connect( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, (<span class="keyword">struct</span> sockaddr *) ctx-&gt;<a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">addr</a>, ctx-&gt;<a class="code" href="a00003.html#a090065b6dfa838ecdf5ca535d6befa24">addr_size</a> );
  } <span class="keywordflow">while</span>( rt == -1 &amp;&amp; errno == EINTR);

  <span class="keywordflow">if</span> (rt == -1) {


<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>     <span class="keywordflow">if</span> (errno != EINPROGRESS) {
        <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
          fprintf(stderr,<span class="stringliteral">&quot;Connect syscall failed. %d\n&quot;</span>, errno );
        }
        <span class="keywordflow">goto</span> err;
     }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
     FD_ZERO(&amp;wset);
     FD_SET(ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>,&amp;wset);
     eset = wset;

     tv.tv_sec = connect_timeout;
     tv.tv_usec = 0;

     <span class="keywordflow">do</span> {
       rt = select( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a> + 1, 0, &amp;wset, &amp;eset, &amp;tv ); 
     } <span class="keywordflow">while</span>( rt == -1 &amp;&amp; errno == EINTR);
     
     <span class="keywordflow">if</span> (rt &lt;= 0) {
        <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
          fprintf(stderr,<span class="stringliteral">&quot;Connect timed out. %d\n&quot;</span>, errno );
        }
        <span class="keywordflow">goto</span> err;
     }

     <span class="keywordflow">if</span> (FD_ISSET( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, &amp;wset) ||  FD_ISSET( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, &amp;eset)) {
       len = <span class="keyword">sizeof</span>(error);
       error = 0;
       <span class="keywordflow">if</span> (getsockopt( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, SOL_SOCKET, SO_ERROR, &amp;error, (socklen_t *) &amp;len ) || error) {
         <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
           fprintf(stderr,<span class="stringliteral">&quot;Connect socket error. %d errno %d\n&quot;</span>, error, errno );
         }
         <span class="keywordflow">goto</span> err;
       }
     }

     <span class="keywordflow">if</span> (! FD_ISSET( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, &amp;wset)) {
         <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
           fprintf(stderr,<span class="stringliteral">&quot;Still not connected. errno %d\n&quot;</span>, errno );
         }
         <span class="keywordflow">goto</span> err;
     }
  }


  ctx-&gt;<a class="code" href="a00003.html#a5283ea4aa0d2447d230e37074a0589ef">connected</a> = 1;
  <span class="keywordflow">return</span> 0;

err:
  <a class="code" href="a00011.html#gad78589add776d85bd1c2e25a9d960eef" title="close the">SOCK_close</a>(ctx);
  <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaa58093540ffae6b2fd5114af70ea9249"></a><!-- doxytag: member="sock.h::SOCK_init" ref="gaa58093540ffae6b2fd5114af70ea9249" args="(SOCKCTX *ctx, int verbose, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creates a socket and sets some options </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. </td></tr>
    <tr><td class="paramname">verbose</td><td></td></tr>
    <tr><td class="paramname">flags</td><td>- bitmask of SOCKTX_FLAGS_xxx values </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00023">23</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> arg;
  <span class="keyword">struct </span>linger l;

  ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a> = verbose;
  ctx-&gt;<a class="code" href="a00003.html#a5283ea4aa0d2447d230e37074a0589ef">connected</a> = 0;

  ctx-&gt;<a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">addr</a> = 0;
  ctx-&gt;<a class="code" href="a00003.html#a090065b6dfa838ecdf5ca535d6befa24">addr_size</a> = 0;

  ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a> = socket( PF_INET, SOCK_STREAM, 0 );
  <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a> == -1) {
     <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
       fprintf(stderr, <span class="stringliteral">&quot;Failed to create socket %d\n&quot;</span>, errno);
     }
     <span class="keywordflow">return</span> -1;
  }

  arg = 0;
  <span class="keywordflow">if</span> (ioctl( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, FIONBIO, &amp;arg ) ) {
     <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
       fprintf(stderr, <span class="stringliteral">&quot;Failed to make socket non blocking errno %d\n&quot;</span>, errno);
     }
  }

  <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="a00011.html#ga387cd63d9202db79a473a4312e50a6d0">SOCKCTX_FLAGS_NAGLE_ON</a>) == 0) {  
    arg = 1;
    <span class="keywordflow">if</span> (setsockopt( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, IPPROTO_TCP, TCP_NODELAY, &amp;arg, <span class="keyword">sizeof</span>(arg) ) ) {
       <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
         fprintf(stderr,<span class="stringliteral">&quot;Failed to set nodelay option (disable nagle algorithm failed). errno %d\n&quot;</span>,errno);
       }    
    }
  }

  ctx-&gt;<a class="code" href="a00003.html#a21ecb44f25561d43dd4b154348562d6a">close_on_peer_close</a> = 1; 
  <span class="keywordflow">if</span> (flags &amp; <a class="code" href="a00011.html#ga4e5ab8d07bf7233fe5358f74f89192d0">SOCKTCX_FLAGS_DONT_CLOSE_ON_PEER_CLOSE</a>) {
    l.l_onoff = 1; l.l_linger = <a class="code" href="a00011.html#ga3adf1d96e791aba989b3bcd0ff855d44">LINGER_OPTION_VALUE</a>;
    <span class="keywordflow">if</span> (setsockopt( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, SOL_SOCKET, SO_LINGER, &amp;l, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> linger) )) {
      <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
       fprintf(stderr,<span class="stringliteral">&quot;Failed to set linger option. %d\n&quot;</span>, errno );
      }
    }
    ctx-&gt;<a class="code" href="a00003.html#a21ecb44f25561d43dd4b154348562d6a">close_on_peer_close</a> = 0; 
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga29f9645369f83530169a0009c19ed35c"></a><!-- doxytag: member="sock.h::SOCK_recv" ref="ga29f9645369f83530169a0009c19ed35c" args="(SOCKCTX *ctx, char *msg, size_t length, int read_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>read some data from a socket with timeout (in seconds) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00201">201</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> rt;
  fd_set rset;
  <span class="keyword">struct </span>timeval tv;
     
retry:
     <span class="keywordflow">do</span> {
       rt = recv( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, msg, length, 0 );
     } <span class="keywordflow">while</span>( rt == -1 &amp;&amp; errno == EINTR );

     <span class="keywordflow">if</span> (rt == -1) {
          
        <span class="keywordflow">if</span> (errno != EAGAIN) {
           <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
             fprintf(stderr,<span class="stringliteral">&quot;recv failed errno %d\n&quot;</span>, errno );
           }
           <span class="keywordflow">goto</span> err;
        }

        FD_ZERO(&amp;rset);
        FD_SET(ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>,&amp;rset);

        tv.tv_sec = read_timeout;
        tv.tv_usec = 0;

        <span class="keywordflow">do</span> {
          rt = select( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a> + 1, &amp;rset, 0, 0, &amp;tv ); 
        } <span class="keywordflow">while</span>( rt == -1 &amp;&amp; errno == EINTR);
        

        <span class="keywordflow">if</span> (rt == -1) {
          <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
            fprintf(stderr, <span class="stringliteral">&quot;select failed. %d\n&quot;</span>, errno );
          }
        }
     
        <span class="keywordflow">if</span> (rt == 0) {
           <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
             fprintf(stderr,<span class="stringliteral">&quot;read timed out\n&quot;</span> );
           }
           <span class="keywordflow">goto</span> err;
        }

        <span class="keywordflow">if</span> (rt == 1) {
           <span class="keywordflow">goto</span> retry;
        }

     }

   <span class="keywordflow">if</span> (rt == 0 &amp;&amp; ctx-&gt;<a class="code" href="a00003.html#a21ecb44f25561d43dd4b154348562d6a">close_on_peer_close</a>  ) {
      <a class="code" href="a00011.html#gad78589add776d85bd1c2e25a9d960eef" title="close the">SOCK_close</a>( ctx );
   }
   <span class="keywordflow">return</span> rt;

err:
   <span class="keywordflow">return</span> -1;
}        
</pre></div>
</div>
</div>
<a class="anchor" id="ga4d44efb92c4cd8cc45d2f7434d0f34bf"></a><!-- doxytag: member="sock.h::SOCK_recv_all" ref="ga4d44efb92c4cd8cc45d2f7434d0f34bf" args="(SOCKCTX *ctx, char *msg, size_t length, int read_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_recv_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>read whe whole buffer from a socket with timeout (in seconds) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00184">184</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">size_t</span> pos;
  <span class="keywordtype">int</span> rt;


  <span class="keywordflow">for</span>(pos = 0; pos &lt; length; ) {
      rt = <a class="code" href="a00011.html#ga29f9645369f83530169a0009c19ed35c" title="read some data from a socket with timeout (in seconds)">SOCK_recv</a>( ctx, msg, length, read_timeout );
      <span class="keywordflow">if</span> (rt &lt;= 0) {
        <span class="keywordflow">return</span> -1;
      }
      pos += rt;
  }
  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabbd75054a6005f6da12fa57a9032495a"></a><!-- doxytag: member="sock.h::SOCK_send" ref="gabbd75054a6005f6da12fa57a9032495a" args="(SOCKCTX *ctx, void *msg, size_t length, int write_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>write whe whole buffer from a socket with timeout (in seconds) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00261">261</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> rt;
  <span class="keywordtype">size_t</span> pos;
  fd_set wset;
  <span class="keyword">struct </span>timeval tv;
  <span class="keywordtype">char</span> *msg = bmsg;

  <span class="keywordflow">for</span>( pos = 0; pos &lt; length; ) {

     <span class="keywordflow">do</span> {
       rt = send( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, msg + pos, length - pos, 0 );
     } <span class="keywordflow">while</span>( rt == -1 &amp;&amp; errno == EINTR );

     <span class="keywordflow">if</span> (rt == -1) {
          
        <span class="keywordflow">if</span> (errno != EAGAIN) {
           <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
             fprintf(stderr,<span class="stringliteral">&quot;send failed errno %d\n&quot;</span>, errno );
           }
           <span class="keywordflow">goto</span> err;
        }

        FD_ZERO(&amp;wset);
        FD_SET(ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>,&amp;wset);

        tv.tv_sec = write_timeout;
        tv.tv_usec = 0;

        <span class="keywordflow">do</span> {
          rt = select( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a> + 1, 0, &amp;wset, 0, &amp;tv ); 
        } <span class="keywordflow">while</span>( rt == -1 &amp;&amp; errno == EINTR);
        

        <span class="keywordflow">if</span> (rt == -1) {
          <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
            fprintf(stderr, <span class="stringliteral">&quot;select failed. %d\n&quot;</span>, errno );
          }
        }
     
        <span class="keywordflow">if</span> (rt == 0) {
           <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>) {
             fprintf(stderr,<span class="stringliteral">&quot;send timed out\n&quot;</span> );
           }
           <span class="keywordflow">goto</span> err;
        }

     }

     pos += rt;
   }
   <span class="keywordflow">return</span> 0;

err:
   <span class="keywordflow">return</span> -1;
}        
</pre></div>
</div>
</div>
<a class="anchor" id="ga691ca5d5947940ef7bb8e05f5f4381ee"></a><!-- doxytag: member="sock.h::SOCK_send_buffer_sizes" ref="ga691ca5d5947940ef7bb8e05f5f4381ee" args="(SOCKCTX *ctx, int read_buffer_size, int write_buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SOCK_send_buffer_sizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">SOCKCTX</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set read and write buffer sizes; a value of -1 for buffer size is ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>- pointer to socket object. </td></tr>
    <tr><td class="paramname">read_buffer_size</td><td></td></tr>
    <tr><td class="paramname">write_buffer_size</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00007_source.html#l00073">73</a> of file <a class="el" href="a00007_source.html">sock.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> val;
  <span class="keywordflow">if</span> (read_buffer_size &gt; 0) {
    val = read_buffer_size;
    <span class="keywordflow">if</span> (setsockopt( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, SOL_SOCKET, SO_RCVBUF, &amp;val, <span class="keyword">sizeof</span>(val) )) {
      fprintf(stderr,<span class="stringliteral">&quot;Failed to set receive buffer size to %d\n&quot;</span>,val);
      <span class="keywordflow">return</span> -1;
    }
  }
  
  <span class="keywordflow">if</span> (write_buffer_size &gt; 0) {
    val = write_buffer_size;
    <span class="keywordflow">if</span> (setsockopt( ctx-&gt;<a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>, SOL_SOCKET, SO_SNDBUF, &amp;val, <span class="keyword">sizeof</span>(val) )) {
      fprintf(stderr,<span class="stringliteral">&quot;Failed to set send buffer size to %d\n&quot;</span>,val);
      <span class="keywordflow">return</span> -1;
    }
  }
  <span class="keywordflow">return</span> 0;  

}
</pre></div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Sep 18 2011 20:14:10 for Simple tools for networking / objects in plain C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
