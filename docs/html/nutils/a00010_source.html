<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simple tools for networking / objects in plain C: sock.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simple tools for networking / objects in plain C&#160;<span id="projectnumber">Snapshot</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">sock.h</div>  </div>
</div>
<div class="contents">
<a href="a00010.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef __SOCKSOCK_H_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define __SOCKSOCK_H_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">/**</span>
<a name="l00006"></a>00006 <span class="comment">  @defgroup SOCKET</span>
<a name="l00007"></a>00007 <span class="comment">  @brief a usable socket abstraction</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">  When you create a socket(2) then it is blocking by default.</span>
<a name="l00010"></a>00010 <span class="comment">  This means that you can&#39;t specify a timeout while using the socket - that makes it useless for any practical purpose.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">  This abstraction creates a non blocking socket, and you can use it in a blocking manner from a thread, alas you can specify timeouts.</span>
<a name="l00013"></a>00013 <span class="comment">  This way you can have &#39;one thread per connection&#39; in a way that allows you to  set timeouts for read, write and connect primitives.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  In a way this wrapper replace one set of utterly incomprehensible default behavior (the Berkley socket api) with another set of behaviour (which maybe makes more sense, maybe it doesn&#39;t - a matter of taste, as many things are with computers)</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">  Still, the Berkley socket interface is supposed to create the illusion, that one can do TCP networking without understanding the protocols. That is an illusion, and one simply has to read &#39;TCP IP Illustrated&#39; by R. Stevens in order to correct it.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">* @{</span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a><a class="code" href="a00003.html">00021</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="a00003.html">tagSOCKCTX</a> {
<a name="l00022"></a>00022 
<a name="l00023"></a><a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">00023</a>   <span class="keywordtype">int</span> <a class="code" href="a00003.html#aaa34bd395f2c627e0497599095582550">verbose</a>;
<a name="l00024"></a><a class="code" href="a00003.html#a5283ea4aa0d2447d230e37074a0589ef">00024</a>   <span class="keywordtype">int</span> <a class="code" href="a00003.html#a5283ea4aa0d2447d230e37074a0589ef">connected</a>;
<a name="l00025"></a><a class="code" href="a00003.html#a21ecb44f25561d43dd4b154348562d6a">00025</a>   <span class="keywordtype">int</span> <a class="code" href="a00003.html#a21ecb44f25561d43dd4b154348562d6a">close_on_peer_close</a>;
<a name="l00026"></a><a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">00026</a>   <span class="keywordtype">int</span> <a class="code" href="a00003.html#addcdd353858c7738ccde887e2fa48501">fd</a>;
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">00028</a>   <span class="keywordtype">void</span> *<a class="code" href="a00003.html#a3d6d0b0910922102ef30609abf8e9abf">addr</a>; 
<a name="l00029"></a><a class="code" href="a00003.html#a090065b6dfa838ecdf5ca535d6befa24">00029</a>   <span class="keywordtype">int</span> <a class="code" href="a00003.html#a090065b6dfa838ecdf5ca535d6befa24">addr_size</a>;
<a name="l00030"></a>00030   
<a name="l00031"></a>00031 } <a class="code" href="a00014.html#ga33ae627ac286035a2b486c6ab593d8af">SOCKCTX</a>;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#ifndef LINGER_OPTION_VALUE</span>
<a name="l00034"></a><a class="code" href="a00014.html#ga3adf1d96e791aba989b3bcd0ff855d44">00034</a> <span class="preprocessor"></span><span class="preprocessor">#define LINGER_OPTION_VALUE 300</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">/**</span>
<a name="l00038"></a>00038 <span class="comment">  if flag is set then nagle algorithm is enabled - this is the opposite behaviour of normal sockets where nagle is enabled by default.</span>
<a name="l00039"></a>00039 <span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment"> The Nagle algorithm makes sense for high latency networks such as the internet; it does not make sense for low latency LAN networks. Here application performance is typically faster without the nagle algorithm. - this stuff therefore assumes</span>
<a name="l00041"></a>00041 <span class="comment"> that is more likely used in a local network.</span>
<a name="l00042"></a>00042 <span class="comment"> </span>
<a name="l00043"></a>00043 <span class="comment"> The Nagle algorithm http://en.wikipedia.org/wiki/Nagle%27s_algorithm tries to combine network writes into larger packets, If the application calls send then the data is not Immediately written out; instead it is gathered with the hope of accumulating data into larger packets, these packets are then sent on the Nagle algorithm&#39;s timer.</span>
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">*/</span>
<a name="l00046"></a><a class="code" href="a00014.html#ga387cd63d9202db79a473a4312e50a6d0">00046</a> <span class="preprocessor">#define SOCKCTX_FLAGS_NAGLE_ON 2</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">/**</span>
<a name="l00049"></a>00049 <span class="comment">  In 99% of all application protocols you will want to close the connection,</span>
<a name="l00050"></a>00050 <span class="comment">  once the peer closes it&#39;s side, and recv returns 0.</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">  Set this option if you do not want the socket closed, once the peer closes it&#39;s side of the connection, and recv returns 0;</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">  Setting this option means the following. Once the peer closes its connection, it is no longer able to</span>
<a name="l00055"></a>00055 <span class="comment">  send data over the connection, howeve the peer still expects to read outstanding data that will be send by the application,</span>
<a name="l00056"></a>00056 <span class="comment">  and the application will send this data after it has received the information that the peer closed its side.</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">  Also, if this options is set, then SO_LINGER option is enabled to the value of LINGER_OPTION_VALUE</span>
<a name="l00059"></a>00059 <span class="comment">  This means that when the socket is closed, and there is data that has to be written still, then close will block</span>
<a name="l00060"></a>00060 <span class="comment">  until the outstanding data has been acknowledged by the peer.</span>
<a name="l00061"></a>00061 <span class="comment">*/</span>
<a name="l00062"></a><a class="code" href="a00014.html#ga4e5ab8d07bf7233fe5358f74f89192d0">00062</a> <span class="preprocessor">#define SOCKTCX_FLAGS_DONT_CLOSE_ON_PEER_CLOSE 4</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">/**</span>
<a name="l00066"></a>00066 <span class="comment">@brief creates a socket and sets some options</span>
<a name="l00067"></a>00067 <span class="comment">@param ctx - pointer to socket object.</span>
<a name="l00068"></a>00068 <span class="comment">@param verbose</span>
<a name="l00069"></a>00069 <span class="comment">@param flags  - bitmask of SOCKTX_FLAGS_xxx values</span>
<a name="l00070"></a>00070 <span class="comment">*/</span>
<a name="l00071"></a>00071 <span class="keywordtype">int</span> <a class="code" href="a00014.html#gaa58093540ffae6b2fd5114af70ea9249" title="creates a socket and sets some options">SOCK_init</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx , <span class="keywordtype">int</span> verbose, <span class="keywordtype">int</span> flags);
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment">/**</span>
<a name="l00074"></a>00074 <span class="comment"> @brief set read and write buffer sizes; a value of -1 for buffer size is ignored.</span>
<a name="l00075"></a>00075 <span class="comment"> @param ctx - pointer to socket object.</span>
<a name="l00076"></a>00076 <span class="comment"> @param read_buffer_size</span>
<a name="l00077"></a>00077 <span class="comment"> @param write_buffer_size</span>
<a name="l00078"></a>00078 <span class="comment"> */</span>
<a name="l00079"></a>00079 <span class="keywordtype">int</span> <a class="code" href="a00014.html#ga691ca5d5947940ef7bb8e05f5f4381ee" title="set read and write buffer sizes; a value of -1 for buffer size is ignored.">SOCK_send_buffer_sizes</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx, <span class="keywordtype">int</span> read_buffer_size, <span class="keywordtype">int</span> write_buffer_size);
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">/**</span>
<a name="l00082"></a>00082 <span class="comment"> @brief connects a sockets with timeout (in seconds)</span>
<a name="l00083"></a>00083 <span class="comment"> @param ctx - pointer to socket object.</span>
<a name="l00084"></a>00084 <span class="comment"> @param addr</span>
<a name="l00085"></a>00085 <span class="comment"> @param addr_size</span>
<a name="l00086"></a>00086 <span class="comment"> @param connect_timeout</span>
<a name="l00087"></a>00087 <span class="comment"> */</span>
<a name="l00088"></a>00088 <span class="keywordtype">int</span> <a class="code" href="a00014.html#ga9a6c6d2ae46cdab6fe52e285f9a8990d" title="connects a sockets with timeout (in seconds)">SOCK_connect</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx, <span class="keywordtype">void</span> *addr, <span class="keywordtype">int</span> addr_size, <span class="keywordtype">int</span> connect_timeout);
<a name="l00089"></a>00089 <span class="comment"></span>
<a name="l00090"></a>00090 <span class="comment">/**</span>
<a name="l00091"></a>00091 <span class="comment"> @brief read some data from a socket with timeout (in seconds)</span>
<a name="l00092"></a>00092 <span class="comment"> @param ctx - pointer to socket object.</span>
<a name="l00093"></a>00093 <span class="comment"> */</span>
<a name="l00094"></a>00094 <span class="keywordtype">int</span> <a class="code" href="a00014.html#ga29f9645369f83530169a0009c19ed35c" title="read some data from a socket with timeout (in seconds)">SOCK_recv</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx, <span class="keywordtype">char</span> *msg, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> read_timeout );
<a name="l00095"></a>00095 <span class="comment"></span>
<a name="l00096"></a>00096 <span class="comment">/**</span>
<a name="l00097"></a>00097 <span class="comment"> @brief read whe whole buffer from a socket with timeout (in seconds)</span>
<a name="l00098"></a>00098 <span class="comment"> @param ctx - pointer to socket object.</span>
<a name="l00099"></a>00099 <span class="comment"> */</span>
<a name="l00100"></a>00100 <span class="keywordtype">int</span> <a class="code" href="a00014.html#ga4d44efb92c4cd8cc45d2f7434d0f34bf" title="read whe whole buffer from a socket with timeout (in seconds)">SOCK_recv_all</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx, <span class="keywordtype">char</span> *msg, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> read_timeout );
<a name="l00101"></a>00101 <span class="comment"></span>
<a name="l00102"></a>00102 <span class="comment">/**</span>
<a name="l00103"></a>00103 <span class="comment"> @brief write whe whole buffer from a socket with timeout (in seconds)</span>
<a name="l00104"></a>00104 <span class="comment"> @param ctx - pointer to socket object.</span>
<a name="l00105"></a>00105 <span class="comment"> */</span>
<a name="l00106"></a>00106 <span class="keywordtype">int</span> <a class="code" href="a00014.html#gabbd75054a6005f6da12fa57a9032495a" title="write whe whole buffer from a socket with timeout (in seconds)">SOCK_send</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx, <span class="keywordtype">void</span> *msg, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> write_timeout );
<a name="l00107"></a>00107 <span class="comment"></span>
<a name="l00108"></a>00108 <span class="comment">/**</span>
<a name="l00109"></a>00109 <span class="comment"> @brief close the </span>
<a name="l00110"></a>00110 <span class="comment"> @param ctx - pointer to socket object.</span>
<a name="l00111"></a>00111 <span class="comment">socket</span>
<a name="l00112"></a>00112 <span class="comment"> */</span>
<a name="l00113"></a>00113 <span class="keywordtype">int</span> <a class="code" href="a00014.html#gad78589add776d85bd1c2e25a9d960eef" title="close the">SOCK_close</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx );
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">/**</span>
<a name="l00116"></a>00116 <span class="comment">@brief ungraceful connection termination.</span>
<a name="l00117"></a>00117 <span class="comment"></span>
<a name="l00118"></a>00118 <span class="comment">This function avoids TIME_WAIT when initiating closing of connection.</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">TIME_WAIT occurs, when the socket has been shut down properly; the application has sent FIN to the peer, and received an ACK for this message; the application has now sent the final last ACK to the peer; the connection is now in TIME_WAIT state and remains so for quite some time. Why? The last ACK might get lost, so TCP wants to make sure that no retransmissions of the last ACK are required.</span>
<a name="l00121"></a>00121 <span class="comment"></span>
<a name="l00122"></a>00122 <span class="comment">For high performance servers this can mean that we will run out of socket handles.</span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">The solution is for the client to terminate the connection ungracefully; instead of sending a FIN packet, the application can send out a RST (reset) packet, this will avoid the whole protocol of closing connections.</span>
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">Here the SO_LINGER option is set with timeout of 0 prior to calling close; this results in sending out the RST packet / terminates the connection ungracefully.</span>
<a name="l00127"></a>00127 <span class="comment"></span>
<a name="l00128"></a>00128 <span class="comment">Note that there is still a chance that the RST packet will get lost; in this we can only hope that the server will close it&#39;s side of the connection due to some connection idle timeout.</span>
<a name="l00129"></a>00129 <span class="comment"> @param ctx - pointer to socket object.</span>
<a name="l00130"></a>00130 <span class="comment">*/</span>
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="keywordtype">int</span> <a class="code" href="a00014.html#gaa4e7c6427b947269086042413e060ed3" title="ungraceful connection termination.">SOCK_close_with_reset</a>( <a class="code" href="a00003.html">SOCKCTX</a> *ctx );
<a name="l00133"></a>00133 <span class="comment"></span>
<a name="l00134"></a>00134 <span class="comment">/**</span>
<a name="l00135"></a>00135 <span class="comment"> * @}</span>
<a name="l00136"></a>00136 <span class="comment"> */</span>
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="preprocessor">#endif</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Sep 26 2011 04:14:36 for Simple tools for networking / objects in plain C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
