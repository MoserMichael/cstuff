<html>
<head>Pooh program example 04-slist.p</title></head>
<body>
<h3>Test 04-slist.p</h3>

<h4>Source of programm</h4>

<pre>
# test linked list data structure - slist.inc
include 'slist.inc'

r := make_slist()

r . insert( ~pos r . head() ~data 1 )
r . insert( ~pos r . nth( ~num 1 ) ~data 2 )
r . insert( ~pos r . nth( ~num 2 ) ~data 3 )
r . insert( ~pos r . nth( ~num 3 ) ~data 4 )
r . insert( ~pos r . nth( ~num 4 ) ~data 5 )
r . insert( ~pos r . nth( ~num 5 ) ~data 6 )

println( ~msg 'the list' )

print_list( ~list r )


println( ~msg 'mapcopy - square all elements and return them in new list' ) 
square := r . mapcopy( ~func sub( arg ) 
                 return arg * arg 
               end )
print_list( ~list square )               


println( ~msg 'mapreplace - square all elements and replace original list with new values returned by argument func' )
r . mapreplace(  ~func sub( arg )
                 return arg * arg
                end )
print_list( ~list r )

println( ~msg 'foldfirst2last - get sum of all numbers in the list' )

sum = r . foldfirst2last( ~func sub( a, b )
                        return a + b
                      end
                    ~initval 0 )
println( ~msg 'sum of elements is [ sum ]' )

println( ~msg 'filtercopy - create new list where all elements are even' )

square := r . filtercopy( ~func sub( arg )
                            return arg % 2 == 0
                          end )
print_list( ~list square )



println( ~msg 'remove the second element' )

r . remove( ~pos r . nth( ~num 1 ) )

print_list( ~list r )


println( ~msg 'test range iterator / for loop - iterate over all elements' )

for n   r.range()
  println( ~msg n )
end

println( ~msg 'test range iterator / for loop - iterate from second to fourth' )

for n   r.range( ~from 2 ~to 4 )
  println( ~msg n )
end

println( ~msg 'test range iterator / for loop - iterate from second to last' )

for n   r.range( ~from 2 )
  println( ~msg n )
end


# ** iterate over the list and print the elements **

sub print_list( list )
    
  pos :=  list . nth( ~num 1 )
  while defined( ~arg pos )
     println( ~msg list . data( ~pos pos ) )
     pos := list . next( ~pos pos )
  end
end







</pre>

<h4>Included file: slist.inc</h4>

<pre>

sub make_slist_node( data optional )
  
  # this ugly construct forces to return a node in heap memory. 
  # i think the notion of a clear language has to be revised a bit ;-)
  l = [ [ Null, data ] ]
  return l[1]
end

# constructs a single linked list . 
# Each node of the list has a link to the next node ; one can move forward among the links of the list, but not backward.
sub make_slist()
  e := make_slist_node( )
  return {
   'headp' : e,
   'ncount' : 0,

   # returns position of the head of the list - 
   # this is an empty node that is maintained for each list; also known as the 0th node.
   'head' : sub()
      rt := this . headp
      return rt
   end,

 
   # given a position (pos argument) returns the data entry for the node identified by the position
   'data' : sub( pos )
      return pos[ 2 ]
   end,

   # given a position (pos argument) returns the next entry following pos.
   'next' : sub( pos )
      rt := pos[ 1 ]
      return rt
   end,

   # returns position of the nth element in the list (0th element is the head of the list)
   'nth' : sub( num )
      pos := this . headp
      while num > 0
        if not defined( ~arg pos )
	  return Null
        end	  
        num = num - 1
	pos := pos [ 1 ]
      end
      return pos
    end,

    # insert new node after node identified by pos argument , the new node will have data argument attached to it.
    'insert' : sub ( pos, data )
      newnode := make_slist_node( ~data data )
      if defined( ~arg pos[ 1 ] )
        newnode[ 1 ] := pos[ 1 ]
      end
      pos[ 1 ] := newnode
      this . ncount = this . ncount + 1

      return newnode
    end,

    # remove the node after the node identified by pos argument
    'remove' : sub( pos )
       if ! defined( ~arg pos )
	  return false
       end	  
       
       rt := pos[ 1 ]

       if defined( ~arg rt )
         pos[ 1 ] := rt[ 1 ]
         this . ncount = this . ncount - 1
	 return true
       end	 
       
       return false       
    end,

    # returns the number of elements in the list; the list object has attached counter of elements.
    'count' : sub() 
        return this . ncount
    end,

    # apply argument function func to each element in the list; returns a new list made up of the results.
    'mapcopy' : sub( func )
       rt := make_slist()
       rpos := rt . headp

       pos := this . headp[ 1 ]
       while defined( ~arg pos )
         fres := func( ~arg pos [ 2 ] )
	 rt . count()
	 rpos := rt . insert( ~pos rpos ~data fres )
         pos := pos[ 1 ]
       end
       return rt
    end,

    # apply argument function func to each element of the list; the original list data entries are replaced with call results.
    'mapreplace' : sub( func )
       pos := this . headp[ 1 ]
       while defined( ~arg pos )
         pos[ 2 ] := func( ~arg pos [ 2 ] )
         pos := pos[ 1 ]
       end
    end,

    # apply argument function to each element of the list; if it returns true then add reference to list data to return list
    'filtercopy' : sub( func )
       rt = make_slist()
       rpos := rt . head()
       pos := this . headp[ 1 ]
       while defined( ~arg pos )
         if func( ~arg pos [ 2 ] )
	    data := pos[ 2 ]
	    rpos := rt . insert( ~pos rpos ~data data )
	 end
         pos := pos[ 1 ]
       end
       return rt
    end,

    # fold the first to last element in the list
    'foldfirst2last' : sub( func, initval )
       pos := this . headp[ 1 ]
       first = 1
       rt = Null
       while defined( ~arg pos )
         if first
            rt = func( ~a initval ~b pos[ 2 ] )
            first = 0
         else
            rt = func( ~a rt ~b pos[ 2 ] )
         end
         pos := pos[ 1 ]
       end
       return rt
     end,

     # list iterator: 
     'range' : sub( from optional, to optional )
	
        
	if ! defined( ~arg from )
          n = 1 
        else
          n = from
	  if n < 1
	    n = 1
	  end
	end

	if ! defined( ~arg to )
	   m = -1
        else 
           m = to
	end
    
	pos := this . nth( ~num n )

        if isthreadmain()
	    while defined( ~arg pos ) 
		if m != -1 and n > m
		    break
		end
		threadyield0( ~yieldval pos[ 2 ] )
		pos := pos[ 1 ]
                n = n + 1
	    end
	else
	    rt = []
	    while defined( ~arg pos ) 
		if m != -1 and n > m
		    break
		end
		tmp := pos[ 2 ]
		push( ~array rt ~top tmp )
		pos := pos[ 1 ]
                n = n + 1
	    end	
	    return rt
	end
     end
  }
end





</pre>

<h4>Trace output for 04-slist.p</h4>

<pre>
003|... := make_slist(  )...
013| ... := make_slist_node(  )...
006|  l = [ [ Null , data:Null] ] 
007|  return l[1]:[ -> Null, -> Null ]
013| e := make_slist_node(  ):-> [ -> Null, -> Null ]
014| return { 'headp' : e:-> [ -> Null, -> Null ] , 'ncount' : 0 , 'head' : sub () , 'data' : sub (~pos) , 'next' : sub (~pos) , 'nth' : sub (~num) , 'insert' : sub (~pos , ~data) , 'remove' : sub (~pos) , 'count' : sub () , 'mapcopy' : sub (~func) , 'mapreplace' : sub (~func) , 'filtercopy' : sub (~func) , 'foldfirst2last' : sub (~func , ~initval) , 'range' : sub (~from , ~to) }
003|r := make_slist(  ):{ 'count' : sub , 'head' : sub , 'foldfirst2last' : sub , 'next' : sub , 'insert' : sub , 'ncount' : -> 0, 'filtercopy' : sub , 'nth' : sub , 'mapreplace' : sub , 'mapcopy' : sub , 'remove' : sub , 'data' : sub , 'range' : sub , 'headp' : -> [ -> Null, -> Null ] }
005|r{'insert'}:sub ( ~pos r{'head'}:sub (  )...
021| rt := this{'headp'}:[ -> Null, -> Null ]
022| return rt:-> [ -> Null, -> Null ]
005|r{'insert'}:sub ( ~pos r{'head'}:sub (  ):-> [ -> Null, -> Null ] ~data 1 )...
052| ... := make_slist_node( ~data data:1 )...
006|  l = [ [ Null , data:1] ] 
007|  return l[1]:[ -> Null, -> 1 ]
052| newnode := make_slist_node( ~data data:1 ):-> [ -> Null, -> 1 ]
053| if defined( ~arg pos[1]:Null )...
053| if defined( ~arg pos[1]:Null ):0
054| end # if
056| pos[1]:[ -> Null, -> 1 ] := newnode:-> [ -> Null, -> 1 ]
057| this{'ncount'}:1 = (this{'ncount'}:0 + 1):1
059| return newnode:-> [ -> Null, -> 1 ]
005|r{'insert'}:sub ( ~pos r{'head'}:sub (  ):-> [ -> Null, -> Null ] ~data 1 ):-> [ -> Null, -> 1 ]
006|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 1 )...
039| pos := this{'headp'}:[ -> [ -> Null, -> 1 ], -> Null ]
040| while (num:1 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 1 ], -> Null ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 1 ], -> Null ] ):1
042|  end # if
044|  num = (num:1 - 1):0
045|  pos := pos[1]:[ -> Null, -> 1 ]
046| end
040| while (num:0 > 0):false
046| end # finish loop
047| return pos:-> [ -> Null, -> 1 ]
006|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 1 ):-> [ -> Null, -> 1 ] ~data 2 )...
052| ... := make_slist_node( ~data data:2 )...
006|  l = [ [ Null , data:2] ] 
007|  return l[1]:[ -> Null, -> 2 ]
052| newnode := make_slist_node( ~data data:2 ):-> [ -> Null, -> 2 ]
053| if defined( ~arg pos[1]:Null )...
053| if defined( ~arg pos[1]:Null ):0
054| end # if
056| pos[1]:[ -> Null, -> 2 ] := newnode:-> [ -> Null, -> 2 ]
057| this{'ncount'}:2 = (this{'ncount'}:1 + 1):2
059| return newnode:-> [ -> Null, -> 2 ]
006|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 1 ):-> [ -> Null, -> 1 ] ~data 2 ):-> [ -> Null, -> 2 ]
007|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 2 )...
039| pos := this{'headp'}:[ -> [ -> [ -> Null, -> 2 ], -> 1 ], -> Null ]
040| while (num:2 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 2 ], -> 1 ], -> Null ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 2 ], -> 1 ], -> Null ] ):1
042|  end # if
044|  num = (num:2 - 1):1
045|  pos := pos[1]:[ -> [ -> Null, -> 2 ], -> 1 ]
046| end
040| while (num:1 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 2 ], -> 1 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 2 ], -> 1 ] ):1
042|  end # if
044|  num = (num:1 - 1):0
045|  pos := pos[1]:[ -> Null, -> 2 ]
046| end
040| while (num:0 > 0):false
046| end # finish loop
047| return pos:-> [ -> Null, -> 2 ]
007|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 2 ):-> [ -> Null, -> 2 ] ~data 3 )...
052| ... := make_slist_node( ~data data:3 )...
006|  l = [ [ Null , data:3] ] 
007|  return l[1]:[ -> Null, -> 3 ]
052| newnode := make_slist_node( ~data data:3 ):-> [ -> Null, -> 3 ]
053| if defined( ~arg pos[1]:Null )...
053| if defined( ~arg pos[1]:Null ):0
054| end # if
056| pos[1]:[ -> Null, -> 3 ] := newnode:-> [ -> Null, -> 3 ]
057| this{'ncount'}:3 = (this{'ncount'}:2 + 1):3
059| return newnode:-> [ -> Null, -> 3 ]
007|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 2 ):-> [ -> Null, -> 2 ] ~data 3 ):-> [ -> Null, -> 3 ]
008|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 3 )...
039| pos := this{'headp'}:[ -> [ -> [ -> [ -> Null, -> 3 ], -> 2 ], -> 1 ], -> Null ]
040| while (num:3 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 3 ], -> 2 ], -> 1 ], -> Null ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 3 ], -> 2 ], -> 1 ], -> Null ] ):1
042|  end # if
044|  num = (num:3 - 1):2
045|  pos := pos[1]:[ -> [ -> [ -> Null, -> 3 ], -> 2 ], -> 1 ]
046| end
040| while (num:2 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 3 ], -> 2 ], -> 1 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 3 ], -> 2 ], -> 1 ] ):1
042|  end # if
044|  num = (num:2 - 1):1
045|  pos := pos[1]:[ -> [ -> Null, -> 3 ], -> 2 ]
046| end
040| while (num:1 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 3 ], -> 2 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 3 ], -> 2 ] ):1
042|  end # if
044|  num = (num:1 - 1):0
045|  pos := pos[1]:[ -> Null, -> 3 ]
046| end
040| while (num:0 > 0):false
046| end # finish loop
047| return pos:-> [ -> Null, -> 3 ]
008|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 3 ):-> [ -> Null, -> 3 ] ~data 4 )...
052| ... := make_slist_node( ~data data:4 )...
006|  l = [ [ Null , data:4] ] 
007|  return l[1]:[ -> Null, -> 4 ]
052| newnode := make_slist_node( ~data data:4 ):-> [ -> Null, -> 4 ]
053| if defined( ~arg pos[1]:Null )...
053| if defined( ~arg pos[1]:Null ):0
054| end # if
056| pos[1]:[ -> Null, -> 4 ] := newnode:-> [ -> Null, -> 4 ]
057| this{'ncount'}:4 = (this{'ncount'}:3 + 1):4
059| return newnode:-> [ -> Null, -> 4 ]
008|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 3 ):-> [ -> Null, -> 3 ] ~data 4 ):-> [ -> Null, -> 4 ]
009|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 4 )...
039| pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ]
040| while (num:4 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ] ):1
042|  end # if
044|  num = (num:4 - 1):3
045|  pos := pos[1]:[ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ]
046| end
040| while (num:3 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):1
042|  end # if
044|  num = (num:3 - 1):2
045|  pos := pos[1]:[ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ]
046| end
040| while (num:2 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ] ):1
042|  end # if
044|  num = (num:2 - 1):1
045|  pos := pos[1]:[ -> [ -> Null, -> 4 ], -> 3 ]
046| end
040| while (num:1 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 4 ], -> 3 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 4 ], -> 3 ] ):1
042|  end # if
044|  num = (num:1 - 1):0
045|  pos := pos[1]:[ -> Null, -> 4 ]
046| end
040| while (num:0 > 0):false
046| end # finish loop
047| return pos:-> [ -> Null, -> 4 ]
009|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 4 ):-> [ -> Null, -> 4 ] ~data 5 )...
052| ... := make_slist_node( ~data data:5 )...
006|  l = [ [ Null , data:5] ] 
007|  return l[1]:[ -> Null, -> 5 ]
052| newnode := make_slist_node( ~data data:5 ):-> [ -> Null, -> 5 ]
053| if defined( ~arg pos[1]:Null )...
053| if defined( ~arg pos[1]:Null ):0
054| end # if
056| pos[1]:[ -> Null, -> 5 ] := newnode:-> [ -> Null, -> 5 ]
057| this{'ncount'}:5 = (this{'ncount'}:4 + 1):5
059| return newnode:-> [ -> Null, -> 5 ]
009|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 4 ):-> [ -> Null, -> 4 ] ~data 5 ):-> [ -> Null, -> 5 ]
010|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 5 )...
039| pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ]
040| while (num:5 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ] ):1
042|  end # if
044|  num = (num:5 - 1):4
045|  pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ]
046| end
040| while (num:4 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):1
042|  end # if
044|  num = (num:4 - 1):3
045|  pos := pos[1]:[ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ]
046| end
040| while (num:3 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ], -> 2 ] ):1
042|  end # if
044|  num = (num:3 - 1):2
045|  pos := pos[1]:[ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ]
046| end
040| while (num:2 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 5 ], -> 4 ], -> 3 ] ):1
042|  end # if
044|  num = (num:2 - 1):1
045|  pos := pos[1]:[ -> [ -> Null, -> 5 ], -> 4 ]
046| end
040| while (num:1 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 5 ], -> 4 ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> Null, -> 5 ], -> 4 ] ):1
042|  end # if
044|  num = (num:1 - 1):0
045|  pos := pos[1]:[ -> Null, -> 5 ]
046| end
040| while (num:0 > 0):false
046| end # finish loop
047| return pos:-> [ -> Null, -> 5 ]
010|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 5 ):-> [ -> Null, -> 5 ] ~data 6 )...
052| ... := make_slist_node( ~data data:6 )...
006|  l = [ [ Null , data:6] ] 
007|  return l[1]:[ -> Null, -> 6 ]
052| newnode := make_slist_node( ~data data:6 ):-> [ -> Null, -> 6 ]
053| if defined( ~arg pos[1]:Null )...
053| if defined( ~arg pos[1]:Null ):0
054| end # if
056| pos[1]:[ -> Null, -> 6 ] := newnode:-> [ -> Null, -> 6 ]
057| this{'ncount'}:6 = (this{'ncount'}:5 + 1):6
059| return newnode:-> [ -> Null, -> 6 ]
010|r{'insert'}:sub ( ~pos r{'nth'}:sub ( ~num 5 ):-> [ -> Null, -> 5 ] ~data 6 ):-> [ -> Null, -> 6 ]
012|println( ~msg 'the list' )...
014|print_list( ~list r:{ 'count' : sub (), 'head' : sub (), 'foldfirst2last' : sub (~func , ~initval), 'next' : sub (~pos), 'insert' : sub (~pos , ~data), 'ncount' : -> 6, 'filtercopy' : sub (~func), 'nth' : sub (~num), 'mapreplace' : sub (~func), 'mapcopy' : sub (~func), 'remove' : sub (~pos), 'data' : sub (~pos), 'range' : sub (~from , ~to), 'headp' : -> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ] } )...
077| ... := list{'nth'}:sub ( ~num 1 )...
039|  pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ]
040|  while (num:1 > 0):true
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ] )...
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ], -> Null ] ):1
042|   end # if
044|   num = (num:1 - 1):0
045|   pos := pos[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ]
046|  end
040|  while (num:0 > 0):false
046|  end # finish loop
047|  return pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ]
077| pos := list{'nth'}:sub ( ~num 1 ):-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ]
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
028|   return pos[2]:1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):-> 1 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ]
034|   return rt:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] )...
028|   return pos[2]:2
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] ):-> 2 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ]
034|   return rt:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] ):-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] )...
028|   return pos[2]:3
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] ):-> 3 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ]
034|   return rt:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] ):-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] )...
028|   return pos[2]:4
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] ):-> 4 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] )...
033|   rt := pos[1]:[ -> [ -> Null, -> 6 ], -> 5 ]
034|   return rt:-> [ -> [ -> Null, -> 6 ], -> 5 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] ):-> [ -> [ -> Null, -> 6 ], -> 5 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] )...
078| while defined( ~arg pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] )...
028|   return pos[2]:5
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] ):-> 5 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] )...
033|   rt := pos[1]:[ -> Null, -> 6 ]
034|   return rt:-> [ -> Null, -> 6 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] ):-> [ -> Null, -> 6 ]
081| end
078| while defined( ~arg pos:-> [ -> Null, -> 6 ] )...
078| while defined( ~arg pos:-> [ -> Null, -> 6 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, -> 6 ] )...
028|   return pos[2]:6
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, -> 6 ] ):-> 6 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> Null, -> 6 ] )...
033|   rt := pos[1]:Null
034|   return rt:-> Null
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> Null, -> 6 ] ):-> Null
081| end
078| while defined( ~arg pos:-> Null )...
078| while defined( ~arg pos:-> Null ):0
081| end # finish loop
017|println( ~msg 'mapcopy - square all elements and return them in new list' )...
018|... := r{'mapcopy'}:sub ( ~func sub (~arg) )...
086| ... := make_slist(  )...
013|  ... := make_slist_node(  )...
006|   l = [ [ Null , data:Null] ] 
007|   return l[1]:[ -> Null, -> Null ]
013|  e := make_slist_node(  ):-> [ -> Null, -> Null ]
014|  return { 'headp' : e:-> [ -> Null, -> Null ] , 'ncount' : 0 , 'head' : sub () , 'data' : sub (~pos) , 'next' : sub (~pos) , 'nth' : sub (~num) , 'insert' : sub (~pos , ~data) , 'remove' : sub (~pos) , 'count' : sub () , 'mapcopy' : sub (~func) , 'mapreplace' : sub (~func) , 'filtercopy' : sub (~func) , 'foldfirst2last' : sub (~func , ~initval) , 'range' : sub (~from , ~to) }
086| rt := make_slist(  ):{ 'count' : sub , 'head' : sub , 'foldfirst2last' : sub , 'next' : sub , 'insert' : sub , 'ncount' : -> 0, 'filtercopy' : sub , 'nth' : sub , 'mapreplace' : sub , 'mapcopy' : sub , 'remove' : sub , 'data' : sub , 'range' : sub , 'headp' : -> [ -> Null, -> Null ] }
087| rpos := rt{'headp'}:[ -> Null, -> Null ]
089| pos := this{'headp'}[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ]
090| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
090| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):1
091|  ... := func:sub ( ~arg pos[2]:1 )...
019|   return (arg:-> 1 * arg:-> 1):1
091|  fres := func:sub ( ~arg pos[2]:1 ):1
092|  rt{'count'}:sub (  )...
081|   return this{'ncount'}:0
092|  rt{'count'}:sub (  ):-> 0
093|  ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> Null ] ~data fres:1 )...
052|   ... := make_slist_node( ~data data:1 )...
006|    l = [ [ Null , data:1] ] 
007|    return l[1]:[ -> Null, -> 1 ]
052|   newnode := make_slist_node( ~data data:1 ):-> [ -> Null, -> 1 ]
053|   if defined( ~arg pos[1]:Null )...
053|   if defined( ~arg pos[1]:Null ):0
054|   end # if
056|   pos[1]:[ -> Null, -> 1 ] := newnode:-> [ -> Null, -> 1 ]
057|   this{'ncount'}:1 = (this{'ncount'}:0 + 1):1
059|   return newnode:-> [ -> Null, -> 1 ]
093|  rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> Null ] ~data fres:1 ):-> [ -> Null, -> 1 ]
094|  pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ]
095| end
090| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] )...
090| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] ):1
091|  ... := func:sub ( ~arg pos[2]:2 )...
019|   return (arg:-> 2 * arg:-> 2):4
091|  fres := func:sub ( ~arg pos[2]:2 ):4
092|  rt{'count'}:sub (  )...
081|   return this{'ncount'}:1
092|  rt{'count'}:sub (  ):-> 1
093|  ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 1 ] ~data fres:4 )...
052|   ... := make_slist_node( ~data data:4 )...
006|    l = [ [ Null , data:4] ] 
007|    return l[1]:[ -> Null, -> 4 ]
052|   newnode := make_slist_node( ~data data:4 ):-> [ -> Null, -> 4 ]
053|   if defined( ~arg pos[1]:Null )...
053|   if defined( ~arg pos[1]:Null ):0
054|   end # if
056|   pos[1]:[ -> Null, -> 4 ] := newnode:-> [ -> Null, -> 4 ]
057|   this{'ncount'}:2 = (this{'ncount'}:1 + 1):2
059|   return newnode:-> [ -> Null, -> 4 ]
093|  rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 1 ] ~data fres:4 ):-> [ -> Null, -> 4 ]
094|  pos := pos[1]:[ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ]
095| end
090| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] )...
090| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] ):1
091|  ... := func:sub ( ~arg pos[2]:3 )...
019|   return (arg:-> 3 * arg:-> 3):9
091|  fres := func:sub ( ~arg pos[2]:3 ):9
092|  rt{'count'}:sub (  )...
081|   return this{'ncount'}:2
092|  rt{'count'}:sub (  ):-> 2
093|  ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 4 ] ~data fres:9 )...
052|   ... := make_slist_node( ~data data:9 )...
006|    l = [ [ Null , data:9] ] 
007|    return l[1]:[ -> Null, -> 9 ]
052|   newnode := make_slist_node( ~data data:9 ):-> [ -> Null, -> 9 ]
053|   if defined( ~arg pos[1]:Null )...
053|   if defined( ~arg pos[1]:Null ):0
054|   end # if
056|   pos[1]:[ -> Null, -> 9 ] := newnode:-> [ -> Null, -> 9 ]
057|   this{'ncount'}:3 = (this{'ncount'}:2 + 1):3
059|   return newnode:-> [ -> Null, -> 9 ]
093|  rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 4 ] ~data fres:9 ):-> [ -> Null, -> 9 ]
094|  pos := pos[1]:[ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ]
095| end
090| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] )...
090| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] ):1
091|  ... := func:sub ( ~arg pos[2]:4 )...
019|   return (arg:-> 4 * arg:-> 4):16
091|  fres := func:sub ( ~arg pos[2]:4 ):16
092|  rt{'count'}:sub (  )...
081|   return this{'ncount'}:3
092|  rt{'count'}:sub (  ):-> 3
093|  ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 9 ] ~data fres:16 )...
052|   ... := make_slist_node( ~data data:16 )...
006|    l = [ [ Null , data:16] ] 
007|    return l[1]:[ -> Null, -> 16 ]
052|   newnode := make_slist_node( ~data data:16 ):-> [ -> Null, -> 16 ]
053|   if defined( ~arg pos[1]:Null )...
053|   if defined( ~arg pos[1]:Null ):0
054|   end # if
056|   pos[1]:[ -> Null, -> 16 ] := newnode:-> [ -> Null, -> 16 ]
057|   this{'ncount'}:4 = (this{'ncount'}:3 + 1):4
059|   return newnode:-> [ -> Null, -> 16 ]
093|  rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 9 ] ~data fres:16 ):-> [ -> Null, -> 16 ]
094|  pos := pos[1]:[ -> [ -> Null, -> 6 ], -> 5 ]
095| end
090| while defined( ~arg pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] )...
090| while defined( ~arg pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] ):1
091|  ... := func:sub ( ~arg pos[2]:5 )...
019|   return (arg:-> 5 * arg:-> 5):25
091|  fres := func:sub ( ~arg pos[2]:5 ):25
092|  rt{'count'}:sub (  )...
081|   return this{'ncount'}:4
092|  rt{'count'}:sub (  ):-> 4
093|  ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 16 ] ~data fres:25 )...
052|   ... := make_slist_node( ~data data:25 )...
006|    l = [ [ Null , data:25] ] 
007|    return l[1]:[ -> Null, -> 25 ]
052|   newnode := make_slist_node( ~data data:25 ):-> [ -> Null, -> 25 ]
053|   if defined( ~arg pos[1]:Null )...
053|   if defined( ~arg pos[1]:Null ):0
054|   end # if
056|   pos[1]:[ -> Null, -> 25 ] := newnode:-> [ -> Null, -> 25 ]
057|   this{'ncount'}:5 = (this{'ncount'}:4 + 1):5
059|   return newnode:-> [ -> Null, -> 25 ]
093|  rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 16 ] ~data fres:25 ):-> [ -> Null, -> 25 ]
094|  pos := pos[1]:[ -> Null, -> 6 ]
095| end
090| while defined( ~arg pos:-> [ -> Null, -> 6 ] )...
090| while defined( ~arg pos:-> [ -> Null, -> 6 ] ):1
091|  ... := func:sub ( ~arg pos[2]:6 )...
019|   return (arg:-> 6 * arg:-> 6):36
091|  fres := func:sub ( ~arg pos[2]:6 ):36
092|  rt{'count'}:sub (  )...
081|   return this{'ncount'}:5
092|  rt{'count'}:sub (  ):-> 5
093|  ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 25 ] ~data fres:36 )...
052|   ... := make_slist_node( ~data data:36 )...
006|    l = [ [ Null , data:36] ] 
007|    return l[1]:[ -> Null, -> 36 ]
052|   newnode := make_slist_node( ~data data:36 ):-> [ -> Null, -> 36 ]
053|   if defined( ~arg pos[1]:Null )...
053|   if defined( ~arg pos[1]:Null ):0
054|   end # if
056|   pos[1]:[ -> Null, -> 36 ] := newnode:-> [ -> Null, -> 36 ]
057|   this{'ncount'}:6 = (this{'ncount'}:5 + 1):6
059|   return newnode:-> [ -> Null, -> 36 ]
093|  rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 25 ] ~data fres:36 ):-> [ -> Null, -> 36 ]
094|  pos := pos[1]:Null
095| end
090| while defined( ~arg pos:-> Null )...
090| while defined( ~arg pos:-> Null ):0
095| end # finish loop
096| return rt:{ 'count' : sub (), 'head' : sub (), 'foldfirst2last' : sub (~func , ~initval), 'next' : sub (~pos), 'insert' : sub (~pos , ~data), 'ncount' : -> 6, 'filtercopy' : sub (~func), 'nth' : sub (~num), 'mapreplace' : sub (~func), 'mapcopy' : sub (~func), 'remove' : sub (~pos), 'data' : sub (~pos), 'range' : sub (~from , ~to), 'headp' : -> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ], -> Null ] }
018|square := r{'mapcopy'}:sub ( ~func sub (~arg) ):{ 'count' : sub , 'head' : sub , 'foldfirst2last' : sub , 'next' : sub , 'insert' : sub , 'ncount' : -> 6, 'filtercopy' : sub , 'nth' : sub , 'mapreplace' : sub , 'mapcopy' : sub , 'remove' : sub , 'data' : sub , 'range' : sub , 'headp' : -> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ], -> Null ] }
021|print_list( ~list square:{ 'count' : sub (), 'head' : sub (), 'foldfirst2last' : sub (~func , ~initval), 'next' : sub (~pos), 'insert' : sub (~pos , ~data), 'ncount' : -> 6, 'filtercopy' : sub (~func), 'nth' : sub (~num), 'mapreplace' : sub (~func), 'mapcopy' : sub (~func), 'remove' : sub (~pos), 'data' : sub (~pos), 'range' : sub (~from , ~to), 'headp' : -> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ], -> Null ] } )...
077| ... := list{'nth'}:sub ( ~num 1 )...
039|  pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ], -> Null ]
040|  while (num:1 > 0):true
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ], -> Null ] )...
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ], -> Null ] ):1
042|   end # if
044|   num = (num:1 - 1):0
045|   pos := pos[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ]
046|  end
040|  while (num:0 > 0):false
046|  end # finish loop
047|  return pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ]
077| pos := list{'nth'}:sub ( ~num 1 ):-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ]
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ] )...
028|   return pos[2]:1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ] ):-> 1 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ]
034|   return rt:-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ], -> 1 ] ):-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ] )...
028|   return pos[2]:4
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ] ):-> 4 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ]
034|   return rt:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ], -> 4 ] ):-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ] )...
028|   return pos[2]:9
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ] ):-> 9 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ]
034|   return rt:-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ], -> 9 ] ):-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ] )...
028|   return pos[2]:16
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ] ):-> 16 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ] )...
033|   rt := pos[1]:[ -> [ -> Null, -> 36 ], -> 25 ]
034|   return rt:-> [ -> [ -> Null, -> 36 ], -> 25 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 25 ], -> 16 ] ):-> [ -> [ -> Null, -> 36 ], -> 25 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> Null, -> 36 ], -> 25 ] )...
078| while defined( ~arg pos:-> [ -> [ -> Null, -> 36 ], -> 25 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 25 ] )...
028|   return pos[2]:25
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 25 ] ):-> 25 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 25 ] )...
033|   rt := pos[1]:[ -> Null, -> 36 ]
034|   return rt:-> [ -> Null, -> 36 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 25 ] ):-> [ -> Null, -> 36 ]
081| end
078| while defined( ~arg pos:-> [ -> Null, -> 36 ] )...
078| while defined( ~arg pos:-> [ -> Null, -> 36 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] )...
028|   return pos[2]:36
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] ):-> 36 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] )...
033|   rt := pos[1]:Null
034|   return rt:-> Null
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] ):-> Null
081| end
078| while defined( ~arg pos:-> Null )...
078| while defined( ~arg pos:-> Null ):0
081| end # finish loop
024|println( ~msg 'mapreplace - square all elements and replace original list with new values returned by argument func' )...
025|r{'mapreplace'}:sub ( ~func sub (~arg) )...
101| pos := this{'headp'}[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ]
102| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
102| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):1
103|  ... := func:sub ( ~arg pos[2]:1 )...
026|   return (arg:-> 1 * arg:-> 1):1
103|  pos[2]:1 := func:sub ( ~arg pos[2]:1 ):1
104|  pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ]
105| end
102| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] )...
102| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ], -> 2 ] ):1
103|  ... := func:sub ( ~arg pos[2]:2 )...
026|   return (arg:-> 2 * arg:-> 2):4
103|  pos[2]:4 := func:sub ( ~arg pos[2]:2 ):4
104|  pos := pos[1]:[ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ]
105| end
102| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] )...
102| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ], -> 3 ] ):1
103|  ... := func:sub ( ~arg pos[2]:3 )...
026|   return (arg:-> 3 * arg:-> 3):9
103|  pos[2]:9 := func:sub ( ~arg pos[2]:3 ):9
104|  pos := pos[1]:[ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ]
105| end
102| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] )...
102| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 6 ], -> 5 ], -> 4 ] ):1
103|  ... := func:sub ( ~arg pos[2]:4 )...
026|   return (arg:-> 4 * arg:-> 4):16
103|  pos[2]:16 := func:sub ( ~arg pos[2]:4 ):16
104|  pos := pos[1]:[ -> [ -> Null, -> 6 ], -> 5 ]
105| end
102| while defined( ~arg pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] )...
102| while defined( ~arg pos:-> [ -> [ -> Null, -> 6 ], -> 5 ] ):1
103|  ... := func:sub ( ~arg pos[2]:5 )...
026|   return (arg:-> 5 * arg:-> 5):25
103|  pos[2]:25 := func:sub ( ~arg pos[2]:5 ):25
104|  pos := pos[1]:[ -> Null, -> 6 ]
105| end
102| while defined( ~arg pos:-> [ -> Null, -> 6 ] )...
102| while defined( ~arg pos:-> [ -> Null, -> 6 ] ):1
103|  ... := func:sub ( ~arg pos[2]:6 )...
026|   return (arg:-> 6 * arg:-> 6):36
103|  pos[2]:36 := func:sub ( ~arg pos[2]:6 ):36
104|  pos := pos[1]:Null
105| end
102| while defined( ~arg pos:-> Null )...
102| while defined( ~arg pos:-> Null ):0
105| end # finish loop
028|print_list( ~list r:{ 'count' : sub (), 'head' : sub (), 'foldfirst2last' : sub (~func , ~initval), 'next' : sub (~pos), 'insert' : sub (~pos , ~data), 'ncount' : -> 6, 'filtercopy' : sub (~func), 'nth' : sub (~num), 'mapreplace' : sub (~func), 'mapcopy' : sub (~func), 'remove' : sub (~pos), 'data' : sub (~pos), 'range' : sub (~from , ~to), 'headp' : -> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ], -> Null ] } )...
077| ... := list{'nth'}:sub ( ~num 1 )...
039|  pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ], -> Null ]
040|  while (num:1 > 0):true
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ], -> Null ] )...
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ], -> Null ] ):1
042|   end # if
044|   num = (num:1 - 1):0
045|   pos := pos[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ]
046|  end
040|  while (num:0 > 0):false
046|  end # finish loop
047|  return pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ]
077| pos := list{'nth'}:sub ( ~num 1 ):-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ]
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] )...
028|   return pos[2]:1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] ):-> 1 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ]
034|   return rt:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] ):-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] )...
028|   return pos[2]:4
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] ):-> 4 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
034|   return rt:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] ):-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
028|   return pos[2]:9
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):-> 9 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
034|   return rt:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
028|   return pos[2]:16
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):-> 16 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
033|   rt := pos[1]:[ -> [ -> Null, 36 ], 25 ]
034|   return rt:-> [ -> [ -> Null, 36 ], 25 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):-> [ -> [ -> Null, 36 ], 25 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] )...
078| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] )...
028|   return pos[2]:25
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] ):-> 25 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] )...
033|   rt := pos[1]:[ -> Null, 36 ]
034|   return rt:-> [ -> Null, 36 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] ):-> [ -> Null, 36 ]
081| end
078| while defined( ~arg pos:-> [ -> Null, 36 ] )...
078| while defined( ~arg pos:-> [ -> Null, 36 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, 36 ] )...
028|   return pos[2]:36
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, 36 ] ):-> 36 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> Null, 36 ] )...
033|   rt := pos[1]:Null
034|   return rt:-> Null
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> Null, 36 ] ):-> Null
081| end
078| while defined( ~arg pos:-> Null )...
078| while defined( ~arg pos:-> Null ):0
081| end # finish loop
030|println( ~msg 'foldfirst2last - get sum of all numbers in the list' )...
032|... = r{'foldfirst2last'}:sub ( ~func sub (~a , ~b) ~initval 0 )...
125| pos := this{'headp'}[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ]
126| first = 1
127| rt = Null
128| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] )...
128| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] ):1
129|  if first:1
130|   ... = func:sub ( ~a initval:0 ~b pos[2]:1 )...
033|    return (a:0 + b:-> 1):1
130|   rt = func:sub ( ~a initval:0 ~b pos[2]:1 ):1
131|   first = 0
131|  end # if
135|  pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ]
136| end
128| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] )...
128| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] ):1
129|  if first:0
131|  else
133|   ... = func:sub ( ~a rt:1 ~b pos[2]:4 )...
033|    return (a:1 + b:-> 4):5
133|   rt = func:sub ( ~a rt:1 ~b pos[2]:4 ):5
133|  end # if
135|  pos := pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
136| end
128| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
128| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):1
129|  if first:0
131|  else
133|   ... = func:sub ( ~a rt:5 ~b pos[2]:9 )...
033|    return (a:5 + b:-> 9):14
133|   rt = func:sub ( ~a rt:5 ~b pos[2]:9 ):14
133|  end # if
135|  pos := pos[1]:[ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
136| end
128| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
128| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):1
129|  if first:0
131|  else
133|   ... = func:sub ( ~a rt:14 ~b pos[2]:16 )...
033|    return (a:14 + b:-> 16):30
133|   rt = func:sub ( ~a rt:14 ~b pos[2]:16 ):30
133|  end # if
135|  pos := pos[1]:[ -> [ -> Null, 36 ], 25 ]
136| end
128| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] )...
128| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] ):1
129|  if first:0
131|  else
133|   ... = func:sub ( ~a rt:30 ~b pos[2]:25 )...
033|    return (a:30 + b:-> 25):55
133|   rt = func:sub ( ~a rt:30 ~b pos[2]:25 ):55
133|  end # if
135|  pos := pos[1]:[ -> Null, 36 ]
136| end
128| while defined( ~arg pos:-> [ -> Null, 36 ] )...
128| while defined( ~arg pos:-> [ -> Null, 36 ] ):1
129|  if first:0
131|  else
133|   ... = func:sub ( ~a rt:55 ~b pos[2]:36 )...
033|    return (a:55 + b:-> 36):91
133|   rt = func:sub ( ~a rt:55 ~b pos[2]:36 ):91
133|  end # if
135|  pos := pos[1]:Null
136| end
128| while defined( ~arg pos:-> Null )...
128| while defined( ~arg pos:-> Null ):0
136| end # finish loop
137| return rt:91
032|sum = r{'foldfirst2last'}:sub ( ~func sub (~a , ~b) ~initval 0 ):91
036|println( ~msg 'sum of elements is ' .. sum:91 .. '' )...
038|println( ~msg 'filtercopy - create new list where all elements are even' )...
040|... := r{'filtercopy'}:sub ( ~func sub (~arg) )...
110| ... = make_slist(  )...
013|  ... := make_slist_node(  )...
006|   l = [ [ Null , data:Null] ] 
007|   return l[1]:[ -> Null, -> Null ]
013|  e := make_slist_node(  ):-> [ -> Null, -> Null ]
014|  return { 'headp' : e:-> [ -> Null, -> Null ] , 'ncount' : 0 , 'head' : sub () , 'data' : sub (~pos) , 'next' : sub (~pos) , 'nth' : sub (~num) , 'insert' : sub (~pos , ~data) , 'remove' : sub (~pos) , 'count' : sub () , 'mapcopy' : sub (~func) , 'mapreplace' : sub (~func) , 'filtercopy' : sub (~func) , 'foldfirst2last' : sub (~func , ~initval) , 'range' : sub (~from , ~to) }
110| rt = make_slist(  ):{ 'count' : sub , 'head' : sub , 'foldfirst2last' : sub , 'next' : sub , 'insert' : sub , 'ncount' : -> 0, 'filtercopy' : sub , 'nth' : sub , 'mapreplace' : sub , 'mapcopy' : sub , 'remove' : sub , 'data' : sub , 'range' : sub , 'headp' : -> [ -> Null, -> Null ] }
111| ... := rt{'head'}:sub (  )...
021|  rt := this{'headp'}:[ -> Null, -> Null ]
022|  return rt:-> [ -> Null, -> Null ]
111| rpos := rt{'head'}:sub (  ):-> [ -> Null, -> Null ]
112| pos := this{'headp'}[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ]
113| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] )...
113| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] ):1
114|  if func:sub ( ~arg pos[2]:1 )...
041|   return ((arg:-> 1 % 2):1 == 0):false
114|  if func:sub ( ~arg pos[2]:1 ):0
116|  end # if
118|  pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ]
119| end
113| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] )...
113| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] ):1
114|  if func:sub ( ~arg pos[2]:4 )...
041|   return ((arg:-> 4 % 2):0 == 0):true
114|  if func:sub ( ~arg pos[2]:4 ):1
115|   data := pos[2]:4
116|   ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> Null ] ~data data:-> 4 )...
052|    ... := make_slist_node( ~data data:-> 4 )...
006|     l = [ [ Null , data:-> 4] ] 
007|     return l[1]:[ -> Null, -> 4 ]
052|    newnode := make_slist_node( ~data data:-> 4 ):-> [ -> Null, -> 4 ]
053|    if defined( ~arg pos[1]:Null )...
053|    if defined( ~arg pos[1]:Null ):0
054|    end # if
056|    pos[1]:[ -> Null, -> 4 ] := newnode:-> [ -> Null, -> 4 ]
057|    this{'ncount'}:1 = (this{'ncount'}:0 + 1):1
059|    return newnode:-> [ -> Null, -> 4 ]
116|   rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> Null ] ~data data:-> 4 ):-> [ -> Null, -> 4 ]
116|  end # if
118|  pos := pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
119| end
113| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
113| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):1
114|  if func:sub ( ~arg pos[2]:9 )...
041|   return ((arg:-> 9 % 2):1 == 0):false
114|  if func:sub ( ~arg pos[2]:9 ):0
116|  end # if
118|  pos := pos[1]:[ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
119| end
113| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
113| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):1
114|  if func:sub ( ~arg pos[2]:16 )...
041|   return ((arg:-> 16 % 2):0 == 0):true
114|  if func:sub ( ~arg pos[2]:16 ):1
115|   data := pos[2]:16
116|   ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 4 ] ~data data:-> 16 )...
052|    ... := make_slist_node( ~data data:-> 16 )...
006|     l = [ [ Null , data:-> 16] ] 
007|     return l[1]:[ -> Null, -> 16 ]
052|    newnode := make_slist_node( ~data data:-> 16 ):-> [ -> Null, -> 16 ]
053|    if defined( ~arg pos[1]:Null )...
053|    if defined( ~arg pos[1]:Null ):0
054|    end # if
056|    pos[1]:[ -> Null, -> 16 ] := newnode:-> [ -> Null, -> 16 ]
057|    this{'ncount'}:2 = (this{'ncount'}:1 + 1):2
059|    return newnode:-> [ -> Null, -> 16 ]
116|   rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 4 ] ~data data:-> 16 ):-> [ -> Null, -> 16 ]
116|  end # if
118|  pos := pos[1]:[ -> [ -> Null, 36 ], 25 ]
119| end
113| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] )...
113| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] ):1
114|  if func:sub ( ~arg pos[2]:25 )...
041|   return ((arg:-> 25 % 2):1 == 0):false
114|  if func:sub ( ~arg pos[2]:25 ):0
116|  end # if
118|  pos := pos[1]:[ -> Null, 36 ]
119| end
113| while defined( ~arg pos:-> [ -> Null, 36 ] )...
113| while defined( ~arg pos:-> [ -> Null, 36 ] ):1
114|  if func:sub ( ~arg pos[2]:36 )...
041|   return ((arg:-> 36 % 2):0 == 0):true
114|  if func:sub ( ~arg pos[2]:36 ):1
115|   data := pos[2]:36
116|   ... := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 16 ] ~data data:-> 36 )...
052|    ... := make_slist_node( ~data data:-> 36 )...
006|     l = [ [ Null , data:-> 36] ] 
007|     return l[1]:[ -> Null, -> 36 ]
052|    newnode := make_slist_node( ~data data:-> 36 ):-> [ -> Null, -> 36 ]
053|    if defined( ~arg pos[1]:Null )...
053|    if defined( ~arg pos[1]:Null ):0
054|    end # if
056|    pos[1]:[ -> Null, -> 36 ] := newnode:-> [ -> Null, -> 36 ]
057|    this{'ncount'}:3 = (this{'ncount'}:2 + 1):3
059|    return newnode:-> [ -> Null, -> 36 ]
116|   rpos := rt{'insert'}:sub ( ~pos rpos:-> [ -> Null, -> 16 ] ~data data:-> 36 ):-> [ -> Null, -> 36 ]
116|  end # if
118|  pos := pos[1]:Null
119| end
113| while defined( ~arg pos:-> Null )...
113| while defined( ~arg pos:-> Null ):0
119| end # finish loop
120| return rt:{ 'count' : sub (), 'head' : sub (), 'foldfirst2last' : sub (~func , ~initval), 'next' : sub (~pos), 'insert' : sub (~pos , ~data), 'ncount' : -> 3, 'filtercopy' : sub (~func), 'nth' : sub (~num), 'mapreplace' : sub (~func), 'mapcopy' : sub (~func), 'remove' : sub (~pos), 'data' : sub (~pos), 'range' : sub (~from , ~to), 'headp' : -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ], -> Null ] }
040|square := r{'filtercopy'}:sub ( ~func sub (~arg) ):{ 'count' : sub , 'head' : sub , 'foldfirst2last' : sub , 'next' : sub , 'insert' : sub , 'ncount' : -> 3, 'filtercopy' : sub , 'nth' : sub , 'mapreplace' : sub , 'mapcopy' : sub , 'remove' : sub , 'data' : sub , 'range' : sub , 'headp' : -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ], -> Null ] }
043|print_list( ~list square:{ 'count' : sub (), 'head' : sub (), 'foldfirst2last' : sub (~func , ~initval), 'next' : sub (~pos), 'insert' : sub (~pos , ~data), 'ncount' : -> 3, 'filtercopy' : sub (~func), 'nth' : sub (~num), 'mapreplace' : sub (~func), 'mapcopy' : sub (~func), 'remove' : sub (~pos), 'data' : sub (~pos), 'range' : sub (~from , ~to), 'headp' : -> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ], -> Null ] } )...
077| ... := list{'nth'}:sub ( ~num 1 )...
039|  pos := this{'headp'}:[ -> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ], -> Null ]
040|  while (num:1 > 0):true
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ], -> Null ] )...
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ], -> Null ] ):1
042|   end # if
044|   num = (num:1 - 1):0
045|   pos := pos[1]:[ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ]
046|  end
040|  while (num:0 > 0):false
046|  end # finish loop
047|  return pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ]
077| pos := list{'nth'}:sub ( ~num 1 ):-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ]
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ] )...
028|   return pos[2]:4
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ] ):-> 4 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ] )...
033|   rt := pos[1]:[ -> [ -> Null, -> 36 ], -> 16 ]
034|   return rt:-> [ -> [ -> Null, -> 36 ], -> 16 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, -> 36 ], -> 16 ], -> 4 ] ):-> [ -> [ -> Null, -> 36 ], -> 16 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> Null, -> 36 ], -> 16 ] )...
078| while defined( ~arg pos:-> [ -> [ -> Null, -> 36 ], -> 16 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 16 ] )...
028|   return pos[2]:16
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 16 ] ):-> 16 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 16 ] )...
033|   rt := pos[1]:[ -> Null, -> 36 ]
034|   return rt:-> [ -> Null, -> 36 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, -> 36 ], -> 16 ] ):-> [ -> Null, -> 36 ]
081| end
078| while defined( ~arg pos:-> [ -> Null, -> 36 ] )...
078| while defined( ~arg pos:-> [ -> Null, -> 36 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] )...
028|   return pos[2]:36
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] ):-> 36 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] )...
033|   rt := pos[1]:Null
034|   return rt:-> Null
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> Null, -> 36 ] ):-> Null
081| end
078| while defined( ~arg pos:-> Null )...
078| while defined( ~arg pos:-> Null ):0
081| end # finish loop
047|println( ~msg 'remove the second element' )...
049|r{'remove'}:sub ( ~pos r{'nth'}:sub ( ~num 1 )...
039| pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ], -> Null ]
040| while (num:1 > 0):true
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ], -> Null ] )...
041|  if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ], -> Null ] ):1
042|  end # if
044|  num = (num:1 - 1):0
045|  pos := pos[1]:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ]
046| end
040| while (num:0 > 0):false
046| end # finish loop
047| return pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ]
049|r{'remove'}:sub ( ~pos r{'nth'}:sub ( ~num 1 ):-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] )...
064| if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] )...
064| if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] ):1
065| end # if
068| rt := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ]
070| if defined( ~arg rt:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] )...
070| if defined( ~arg rt:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ] ):1
071|  pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] := rt[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
072|  this{'ncount'}:5 = (this{'ncount'}:6 - 1):5
073|  return 1
073| end # if
049|r{'remove'}:sub ( ~pos r{'nth'}:sub ( ~num 1 ):-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 4 ], 1 ] ):1
051|print_list( ~list r:{ 'count' : sub (), 'head' : sub (), 'foldfirst2last' : sub (~func , ~initval), 'next' : sub (~pos), 'insert' : sub (~pos , ~data), 'ncount' : -> 5, 'filtercopy' : sub (~func), 'nth' : sub (~num), 'mapreplace' : sub (~func), 'mapcopy' : sub (~func), 'remove' : sub (~pos), 'data' : sub (~pos), 'range' : sub (~from , ~to), 'headp' : -> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] } )...
077| ... := list{'nth'}:sub ( ~num 1 )...
039|  pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ]
040|  while (num:1 > 0):true
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] )...
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] ):1
042|   end # if
044|   num = (num:1 - 1):0
045|   pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
046|  end
040|  while (num:0 > 0):false
046|  end # finish loop
047|  return pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
077| pos := list{'nth'}:sub ( ~num 1 ):-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] )...
028|   return pos[2]:1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] ):-> 1 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
034|   return rt:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] ):-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
028|   return pos[2]:9
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):-> 9 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
033|   rt := pos[1]:[ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
034|   return rt:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
078| while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
028|   return pos[2]:16
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):-> 16 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
033|   rt := pos[1]:[ -> [ -> Null, 36 ], 25 ]
034|   return rt:-> [ -> [ -> Null, 36 ], 25 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):-> [ -> [ -> Null, 36 ], 25 ]
081| end
078| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] )...
078| while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] )...
028|   return pos[2]:25
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] ):-> 25 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] )...
033|   rt := pos[1]:[ -> Null, 36 ]
034|   return rt:-> [ -> Null, 36 ]
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> [ -> Null, 36 ], 25 ] ):-> [ -> Null, 36 ]
081| end
078| while defined( ~arg pos:-> [ -> Null, 36 ] )...
078| while defined( ~arg pos:-> [ -> Null, 36 ] ):1
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, 36 ] )...
028|   return pos[2]:36
079|  println( ~msg list{'data'}:sub ( ~pos pos:-> [ -> Null, 36 ] ):-> 36 )...
080|  ... := list{'next'}:sub ( ~pos pos:-> [ -> Null, 36 ] )...
033|   rt := pos[1]:Null
034|   return rt:-> Null
080|  pos := list{'next'}:sub ( ~pos pos:-> [ -> Null, 36 ] ):-> Null
081| end
078| while defined( ~arg pos:-> Null )...
078| while defined( ~arg pos:-> Null ):0
081| end # finish loop
054|println( ~msg 'test range iterator / for loop - iterate over all elements' )...
056|for ... r{'range'}:sub (  )...
144| if  not defined( ~arg from:-> Null )...
144| if  not defined( ~arg from:-> Null ):0
145|  n = 1
145| end # if
153| if  not defined( ~arg to:-> Null )...
153| if  not defined( ~arg to:-> Null ):0
154|  m =  - 1
154| end # if
159| ... := this{'nth'}:sub ( ~num n:1 )...
039|  pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ]
040|  while (num:1 > 0):true
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] )...
041|   if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] ):1
042|   end # if
044|   num = (num:1 - 1):0
045|   pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
046|  end
040|  while (num:0 > 0):false
046|  end # finish loop
047|  return pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
159| pos := this{'nth'}:sub ( ~num n:1 ):-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
161| if isthreadmain(  )...
161| if isthreadmain(  ):1
162|  while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] )...
162|  while defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] ):1
163|   if ((m:-1 !=  - 1):false and _ ):):false
164|   end # if
166|   threadyield0( ~yieldval pos[2]:1 )...
056|    for n = 1
057|     println( ~msg n:1 )...
056|    end
056|    for ...
166|   threadyield0( ~yieldval pos[2]:1 ):-> Null
167|   pos := pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
168|   n = (n:1 + 1):2
169|  end
162|  while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
162|  while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):1
163|   if ((m:-1 !=  - 1):false and _ ):):false
164|   end # if
166|   threadyield0( ~yieldval pos[2]:9 )...
056|    for n = 9
057|     println( ~msg n:9 )...
056|    end
056|    for ...
166|   threadyield0( ~yieldval pos[2]:9 ):-> Null
167|   pos := pos[1]:[ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
168|   n = (n:2 + 1):3
169|  end
162|  while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
162|  while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):1
163|   if ((m:-1 !=  - 1):false and _ ):):false
164|   end # if
166|   threadyield0( ~yieldval pos[2]:16 )...
056|    for n = 16
057|     println( ~msg n:16 )...
056|    end
056|    for ...
166|   threadyield0( ~yieldval pos[2]:16 ):-> Null
167|   pos := pos[1]:[ -> [ -> Null, 36 ], 25 ]
168|   n = (n:3 + 1):4
169|  end
162|  while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] )...
162|  while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] ):1
163|   if ((m:-1 !=  - 1):false and _ ):):false
164|   end # if
166|   threadyield0( ~yieldval pos[2]:25 )...
056|    for n = 25
057|     println( ~msg n:25 )...
056|    end
056|    for ...
166|   threadyield0( ~yieldval pos[2]:25 ):-> Null
167|   pos := pos[1]:[ -> Null, 36 ]
168|   n = (n:4 + 1):5
169|  end
162|  while defined( ~arg pos:-> [ -> Null, 36 ] )...
162|  while defined( ~arg pos:-> [ -> Null, 36 ] ):1
163|   if ((m:-1 !=  - 1):false and _ ):):false
164|   end # if
166|   threadyield0( ~yieldval pos[2]:36 )...
056|    for n = 36
057|     println( ~msg n:36 )...
056|    end
056|    for ...
166|   threadyield0( ~yieldval pos[2]:36 ):-> Null
167|   pos := pos[1]:Null
168|   n = (n:5 + 1):6
169|  end
162|  while defined( ~arg pos:-> Null )...
162|  while defined( ~arg pos:-> Null ):0
169|  end # finish loop
169| end # if
056| end # finish for loop
060| println( ~msg 'test range iterator / for loop - iterate from second to fourth' )...
062| for ... r{'range'}:sub ( ~from 2 ~to 4 )...
144|  if  not defined( ~arg from:-> 2 )...
144|  if  not defined( ~arg from:-> 2 ):1
145|  else
147|   n = from:-> 2
148|   if (n:2 < 1):false
149|   end # if
150|  end # if
153|  if  not defined( ~arg to:-> 4 )...
153|  if  not defined( ~arg to:-> 4 ):1
154|  else
156|   m = to:-> 4
156|  end # if
159|  ... := this{'nth'}:sub ( ~num n:2 )...
039|   pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ]
040|   while (num:2 > 0):true
041|    if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] )...
041|    if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] ):1
042|    end # if
044|    num = (num:2 - 1):1
045|    pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
046|   end
040|   while (num:1 > 0):true
041|    if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] )...
041|    if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] ):1
042|    end # if
044|    num = (num:1 - 1):0
045|    pos := pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
046|   end
040|   while (num:0 > 0):false
046|   end # finish loop
047|   return pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
159|  pos := this{'nth'}:sub ( ~num n:2 ):-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
161|  if isthreadmain(  )...
161|  if isthreadmain(  ):1
162|   while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
162|   while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):1
163|    if ((m:4 !=  - 1):true and (n:2 > m:4):false):false
164|    end # if
166|    threadyield0( ~yieldval pos[2]:9 )...
062|     for n = 9
063|      println( ~msg n:9 )...
062|     end
062|     for ...
166|    threadyield0( ~yieldval pos[2]:9 ):-> Null
167|    pos := pos[1]:[ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
168|    n = (n:2 + 1):3
169|   end
162|   while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
162|   while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):1
163|    if ((m:4 !=  - 1):true and (n:3 > m:4):false):false
164|    end # if
166|    threadyield0( ~yieldval pos[2]:16 )...
062|     for n = 16
063|      println( ~msg n:16 )...
062|     end
062|     for ...
166|    threadyield0( ~yieldval pos[2]:16 ):-> Null
167|    pos := pos[1]:[ -> [ -> Null, 36 ], 25 ]
168|    n = (n:3 + 1):4
169|   end
162|   while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] )...
162|   while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] ):1
163|    if ((m:4 !=  - 1):true and (n:4 > m:4):false):false
164|    end # if
166|    threadyield0( ~yieldval pos[2]:25 )...
062|     for n = 25
063|      println( ~msg n:25 )...
062|     end
062|     for ...
166|    threadyield0( ~yieldval pos[2]:25 ):-> Null
167|    pos := pos[1]:[ -> Null, 36 ]
168|    n = (n:4 + 1):5
169|   end
162|   while defined( ~arg pos:-> [ -> Null, 36 ] )...
162|   while defined( ~arg pos:-> [ -> Null, 36 ] ):1
163|    if ((m:4 !=  - 1):true and (n:5 > m:4):true):true
164|     break
164|    end # if
169|   end # finish loop
169|  end # if
062|  end # finish for loop
066|  println( ~msg 'test range iterator / for loop - iterate from second to last' )...
068|  for ... r{'range'}:sub ( ~from 2 )...
144|   if  not defined( ~arg from:-> 2 )...
144|   if  not defined( ~arg from:-> 2 ):1
145|   else
147|    n = from:-> 2
148|    if (n:2 < 1):false
149|    end # if
150|   end # if
153|   if  not defined( ~arg to:-> Null )...
153|   if  not defined( ~arg to:-> Null ):0
154|    m =  - 1
154|   end # if
159|   ... := this{'nth'}:sub ( ~num n:2 )...
039|    pos := this{'headp'}:[ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ]
040|    while (num:2 > 0):true
041|     if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] )...
041|     if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ], -> Null ] ):1
042|     end # if
044|     num = (num:2 - 1):1
045|     pos := pos[1]:[ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ]
046|    end
040|    while (num:1 > 0):true
041|     if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] )...
041|     if  not defined( ~arg pos:-> [ -> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ], 1 ] ):1
042|     end # if
044|     num = (num:1 - 1):0
045|     pos := pos[1]:[ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
046|    end
040|    while (num:0 > 0):false
046|    end # finish loop
047|    return pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
159|   pos := this{'nth'}:sub ( ~num n:2 ):-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ]
161|   if isthreadmain(  )...
161|   if isthreadmain(  ):1
162|    while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] )...
162|    while defined( ~arg pos:-> [ -> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ], 9 ] ):1
163|     if ((m:-1 !=  - 1):false and _ ):):false
164|     end # if
166|     threadyield0( ~yieldval pos[2]:9 )...
068|      for n = 9
069|       println( ~msg n:9 )...
068|      end
068|      for ...
166|     threadyield0( ~yieldval pos[2]:9 ):-> Null
167|     pos := pos[1]:[ -> [ -> [ -> Null, 36 ], 25 ], 16 ]
168|     n = (n:2 + 1):3
169|    end
162|    while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] )...
162|    while defined( ~arg pos:-> [ -> [ -> [ -> Null, 36 ], 25 ], 16 ] ):1
163|     if ((m:-1 !=  - 1):false and _ ):):false
164|     end # if
166|     threadyield0( ~yieldval pos[2]:16 )...
068|      for n = 16
069|       println( ~msg n:16 )...
068|      end
068|      for ...
166|     threadyield0( ~yieldval pos[2]:16 ):-> Null
167|     pos := pos[1]:[ -> [ -> Null, 36 ], 25 ]
168|     n = (n:3 + 1):4
169|    end
162|    while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] )...
162|    while defined( ~arg pos:-> [ -> [ -> Null, 36 ], 25 ] ):1
163|     if ((m:-1 !=  - 1):false and _ ):):false
164|     end # if
166|     threadyield0( ~yieldval pos[2]:25 )...
068|      for n = 25
069|       println( ~msg n:25 )...
068|      end
068|      for ...
166|     threadyield0( ~yieldval pos[2]:25 ):-> Null
167|     pos := pos[1]:[ -> Null, 36 ]
168|     n = (n:4 + 1):5
169|    end
162|    while defined( ~arg pos:-> [ -> Null, 36 ] )...
162|    while defined( ~arg pos:-> [ -> Null, 36 ] ):1
163|     if ((m:-1 !=  - 1):false and _ ):):false
164|     end # if
166|     threadyield0( ~yieldval pos[2]:36 )...
068|      for n = 36
069|       println( ~msg n:36 )...
068|      end
068|      for ...
166|     threadyield0( ~yieldval pos[2]:36 ):-> Null
167|     pos := pos[1]:Null
168|     n = (n:5 + 1):6
169|    end
162|    while defined( ~arg pos:-> Null )...
162|    while defined( ~arg pos:-> Null ):0
169|    end # finish loop
169|   end # if
068|   end # finish for loop
</pre>

<h3>Standard output for 04-slist.p</h3>

<pre>
the list
1
2
3
4
5
6
mapcopy - square all elements and return them in new list
1
4
9
16
25
36
mapreplace - square all elements and replace original list with new values returned by argument func
1
4
9
16
25
36
foldfirst2last - get sum of all numbers in the list
sum of elements is 91
filtercopy - create new list where all elements are even
4
16
36
remove the second element
1
9
16
25
36
test range iterator / for loop - iterate over all elements
1
9
16
25
36
test range iterator / for loop - iterate from second to fourth
9
16
25
test range iterator / for loop - iterate from second to last
9
16
25
36

</pre>
</html>
</body>
