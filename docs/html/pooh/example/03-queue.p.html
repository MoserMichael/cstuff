<html>
<head>Pooh program example 03-queue.p</title></head>
<body>
<h3>Test 03-queue.p</h3>

<h4>Source of programm</h4>

<pre>
# test queue data structure - queue.inc
include 'queue.inc'

println( ~msg 'queue of numbers' )

l = make_queue()

l . push( ~data 1 )
l . push( ~data 2 )
l . push( ~data 3 )
l . push( ~data 4 )

while  l . count() != 0
  r = l . pop( )
  println( ~msg r )
end

println( ~msg 'stack of arrays' )

l . push( ~data [ 1, 2] )
l . push( ~data [ 2, 3] )
l . push( ~data [ 3, 4] )
l . push( ~data [ 5, 6] )

while  l . count() != 0
  r = l . pop( )
  println( ~msg join( ~array r ~separator ' - ' ) )
end



print( ~msg '*** eof stack test ***' )




</pre>

<h4>Included file: queue.inc</h4>

<pre>

sub make_queue_node( data optional )
  
  # this ugly construct forces to return a node in heap memory. 
  # i think the notion of a clear language has to be revised a bit ;-)
  l = [ [ Null, data ] ]
  return l[1]
end

# constructs a linked list stack
sub make_queue()
  e := make_queue_node( )
  return {
   'head' : e,
   'tail' : e,
   'ncount' : 0,
  
   # add new element to the top of the stack
   'push' : sub( data )
        newnode := make_queue_node( ~data data )
        this . tail[ 1 ] := newnode
        this . ncount = this . ncount + 1

	#this . tail := Null
	this . tail := newnode
        
        #dump( ~arg this . head )
        #println( ~msg '***' )
     end,

    # removes an element from the stack; the last value inserted with push is the first one returned by pop.
   'pop' : sub( )
        if ! defined( ~arg this . head[ 1 ] )
          return Null
        end
        rt := this . head[ 1 ]
        this . head[ 1 ]   := rt[ 1 ]
        this . ncount = this . ncount - 1

	if this . ncount == 0
	   this . tail := this . head 
	end
        
        #dump( ~arg this . head )
        #println( ~msg '***' )

        return rt[ 2 ]
    end,

    'count' : sub() 
        return this . ncount
    end        
 
  }
end



</pre>
</pre>

<h3>Standard output for 03-queue.p</h3>

<pre>
queue of numbers
1
2
3
4
stack of arrays
1 - 2
2 - 3
3 - 4
5 - 6
*** eof stack test ***
<h4>Trace output for 03-queue.p</h4>

<pre>
003|println( ~msg 'queue of numbers' )...
005|... = make_queue(  )...
012| ... := make_queue_node(  )...
006|  l = [ [ Null , data:Null] ] 
007|  return l[1]:[ -> Null, -> Null ]
012| e := make_queue_node(  ):-> [ -> Null, -> Null ]
013| return { 'head' : e:-> [ -> Null, -> Null ] , 'tail' : e:-> [ -> Null, -> Null ] , 'ncount' : 0 , 'push' : sub (~data) , 'pop' : sub () , 'count' : sub () }
005|l = make_queue(  ):{ 'count' : sub , 'head' : -> (0x8f708f8)[ -> Null, -> Null ], 'pop' : sub , 'ncount' : -> 0, 'tail' : -> <0x8f708f8> , 'push' : sub  }
007|l{'push'}:sub ( ~data 1 )...
020| ... := make_queue_node( ~data data:1 )...
006|  l = [ [ Null , data:1] ] 
007|  return l[1]:[ -> Null, -> 1 ]
020| newnode := make_queue_node( ~data data:1 ):-> [ -> Null, -> 1 ]
021| this{'tail'}[1]:[ -> Null, -> 1 ] := newnode:-> [ -> Null, -> 1 ]
022| this{'ncount'}:1 = (this{'ncount'}:0 + 1):1
025| this{'tail'}:[ -> Null, -> 1 ] := newnode:-> [ -> Null, -> 1 ]
008|l{'push'}:sub ( ~data 2 )...
020| ... := make_queue_node( ~data data:2 )...
006|  l = [ [ Null , data:2] ] 
007|  return l[1]:[ -> Null, -> 2 ]
020| newnode := make_queue_node( ~data data:2 ):-> [ -> Null, -> 2 ]
021| this{'tail'}[1]:[ -> Null, -> 2 ] := newnode:-> [ -> Null, -> 2 ]
022| this{'ncount'}:2 = (this{'ncount'}:1 + 1):2
025| this{'tail'}:[ -> Null, -> 2 ] := newnode:-> [ -> Null, -> 2 ]
009|l{'push'}:sub ( ~data 3 )...
020| ... := make_queue_node( ~data data:3 )...
006|  l = [ [ Null , data:3] ] 
007|  return l[1]:[ -> Null, -> 3 ]
020| newnode := make_queue_node( ~data data:3 ):-> [ -> Null, -> 3 ]
021| this{'tail'}[1]:[ -> Null, -> 3 ] := newnode:-> [ -> Null, -> 3 ]
022| this{'ncount'}:3 = (this{'ncount'}:2 + 1):3
025| this{'tail'}:[ -> Null, -> 3 ] := newnode:-> [ -> Null, -> 3 ]
010|l{'push'}:sub ( ~data 4 )...
020| ... := make_queue_node( ~data data:4 )...
006|  l = [ [ Null , data:4] ] 
007|  return l[1]:[ -> Null, -> 4 ]
020| newnode := make_queue_node( ~data data:4 ):-> [ -> Null, -> 4 ]
021| this{'tail'}[1]:[ -> Null, -> 4 ] := newnode:-> [ -> Null, -> 4 ]
022| this{'ncount'}:4 = (this{'ncount'}:3 + 1):4
025| this{'tail'}:[ -> Null, -> 4 ] := newnode:-> [ -> Null, -> 4 ]
012|while (l{'count'}:sub (  )...
051| return this{'ncount'}:4
012|while (l{'count'}:sub (  ):-> 4 != 0):true
013| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> [ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ], -> 1 ]
037|  this{'head'}[1]:[ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ] := rt[1]:[ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ]
038|  this{'ncount'}:3 = (this{'ncount'}:4 - 1):3
040|  if (this{'ncount'}:3 == 0):false
041|  end # if
047|  return rt[2]:1
013| r = l{'pop'}:sub (  ):-> 1
014| println( ~msg r:1 )...
015|end
012|while (l{'count'}:sub (  )...
051| return this{'ncount'}:3
012|while (l{'count'}:sub (  ):-> 3 != 0):true
013| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> [ -> [ -> Null, -> 4 ], -> 3 ], -> 2 ]
037|  this{'head'}[1]:[ -> [ -> Null, -> 4 ], -> 3 ] := rt[1]:[ -> [ -> Null, -> 4 ], -> 3 ]
038|  this{'ncount'}:2 = (this{'ncount'}:3 - 1):2
040|  if (this{'ncount'}:2 == 0):false
041|  end # if
047|  return rt[2]:2
013| r = l{'pop'}:sub (  ):-> 2
014| println( ~msg r:2 )...
015|end
012|while (l{'count'}:sub (  )...
051| return this{'ncount'}:2
012|while (l{'count'}:sub (  ):-> 2 != 0):true
013| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> Null, -> 4 ], -> 3 ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> Null, -> 4 ], -> 3 ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> [ -> Null, -> 4 ], -> 3 ]
037|  this{'head'}[1]:[ -> Null, -> 4 ] := rt[1]:[ -> Null, -> 4 ]
038|  this{'ncount'}:1 = (this{'ncount'}:2 - 1):1
040|  if (this{'ncount'}:1 == 0):false
041|  end # if
047|  return rt[2]:3
013| r = l{'pop'}:sub (  ):-> 3
014| println( ~msg r:3 )...
015|end
012|while (l{'count'}:sub (  )...
051| return this{'ncount'}:1
012|while (l{'count'}:sub (  ):-> 1 != 0):true
013| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> Null, -> 4 ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> Null, -> 4 ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> Null, -> 4 ]
037|  this{'head'}[1]:Null := rt[1]:Null
038|  this{'ncount'}:0 = (this{'ncount'}:1 - 1):0
040|  if (this{'ncount'}:0 == 0):true
041|   this{'tail'}:[ -> Null, -> Null ] := this{'head'}:[ -> Null, -> Null ]
041|  end # if
047|  return rt[2]:4
013| r = l{'pop'}:sub (  ):-> 4
014| println( ~msg r:4 )...
015|end
012|while (l{'count'}:sub (  )...
051| return this{'ncount'}:0
012|while (l{'count'}:sub (  ):-> 0 != 0):false
015|end # finish loop
017|println( ~msg 'stack of arrays' )...
019|l{'push'}:sub ( ~data [ 1 , 2]  )...
020| ... := make_queue_node( ~data data:[ -> 1, -> 2 ] )...
006|  l = [ [ Null , data:-> [ -> 1, -> 2 ]] ] 
007|  return l[1]:[ -> Null, -> [ -> 1, -> 2 ] ]
020| newnode := make_queue_node( ~data data:[ -> 1, -> 2 ] ):-> [ -> Null, -> [ -> 1, -> 2 ] ]
021| this{'tail'}[1]:[ -> Null, -> [ -> 1, -> 2 ] ] := newnode:-> [ -> Null, -> [ -> 1, -> 2 ] ]
022| this{'ncount'}:1 = (this{'ncount'}:0 + 1):1
025| this{'tail'}:[ -> Null, -> [ -> 1, -> 2 ] ] := newnode:-> [ -> Null, -> [ -> 1, -> 2 ] ]
020|l{'push'}:sub ( ~data [ 2 , 3]  )...
020| ... := make_queue_node( ~data data:[ -> 2, -> 3 ] )...
006|  l = [ [ Null , data:-> [ -> 2, -> 3 ]] ] 
007|  return l[1]:[ -> Null, -> [ -> 2, -> 3 ] ]
020| newnode := make_queue_node( ~data data:[ -> 2, -> 3 ] ):-> [ -> Null, -> [ -> 2, -> 3 ] ]
021| this{'tail'}[1]:[ -> Null, -> [ -> 2, -> 3 ] ] := newnode:-> [ -> Null, -> [ -> 2, -> 3 ] ]
022| this{'ncount'}:2 = (this{'ncount'}:1 + 1):2
025| this{'tail'}:[ -> Null, -> [ -> 2, -> 3 ] ] := newnode:-> [ -> Null, -> [ -> 2, -> 3 ] ]
021|l{'push'}:sub ( ~data [ 3 , 4]  )...
020| ... := make_queue_node( ~data data:[ -> 3, -> 4 ] )...
006|  l = [ [ Null , data:-> [ -> 3, -> 4 ]] ] 
007|  return l[1]:[ -> Null, -> [ -> 3, -> 4 ] ]
020| newnode := make_queue_node( ~data data:[ -> 3, -> 4 ] ):-> [ -> Null, -> [ -> 3, -> 4 ] ]
021| this{'tail'}[1]:[ -> Null, -> [ -> 3, -> 4 ] ] := newnode:-> [ -> Null, -> [ -> 3, -> 4 ] ]
022| this{'ncount'}:3 = (this{'ncount'}:2 + 1):3
025| this{'tail'}:[ -> Null, -> [ -> 3, -> 4 ] ] := newnode:-> [ -> Null, -> [ -> 3, -> 4 ] ]
022|l{'push'}:sub ( ~data [ 5 , 6]  )...
020| ... := make_queue_node( ~data data:[ -> 5, -> 6 ] )...
006|  l = [ [ Null , data:-> [ -> 5, -> 6 ]] ] 
007|  return l[1]:[ -> Null, -> [ -> 5, -> 6 ] ]
020| newnode := make_queue_node( ~data data:[ -> 5, -> 6 ] ):-> [ -> Null, -> [ -> 5, -> 6 ] ]
021| this{'tail'}[1]:[ -> Null, -> [ -> 5, -> 6 ] ] := newnode:-> [ -> Null, -> [ -> 5, -> 6 ] ]
022| this{'ncount'}:4 = (this{'ncount'}:3 + 1):4
025| this{'tail'}:[ -> Null, -> [ -> 5, -> 6 ] ] := newnode:-> [ -> Null, -> [ -> 5, -> 6 ] ]
024|while (l{'count'}:sub (  )...
051| return this{'ncount'}:4
024|while (l{'count'}:sub (  ):-> 4 != 0):true
025| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ], -> [ -> 1, -> 2 ] ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ], -> [ -> 1, -> 2 ] ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> [ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ], -> [ -> 1, -> 2 ] ]
037|  this{'head'}[1]:[ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ] := rt[1]:[ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ]
038|  this{'ncount'}:3 = (this{'ncount'}:4 - 1):3
040|  if (this{'ncount'}:3 == 0):false
041|  end # if
047|  return rt[2]:[ -> 1, -> 2 ]
025| r = l{'pop'}:sub (  ):-> [ -> 1, -> 2 ]
026| println( ~msg join( ~array r:[ -> 1, -> 2 ] ~separator ' - ' )...
026| println( ~msg join( ~array r:[ -> 1, -> 2 ] ~separator ' - ' ):'1 - 2' )...
027|end
024|while (l{'count'}:sub (  )...
051| return this{'ncount'}:3
024|while (l{'count'}:sub (  ):-> 3 != 0):true
025| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> [ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ], -> [ -> 2, -> 3 ] ]
037|  this{'head'}[1]:[ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ] := rt[1]:[ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ]
038|  this{'ncount'}:2 = (this{'ncount'}:3 - 1):2
040|  if (this{'ncount'}:2 == 0):false
041|  end # if
047|  return rt[2]:[ -> 2, -> 3 ]
025| r = l{'pop'}:sub (  ):-> [ -> 2, -> 3 ]
026| println( ~msg join( ~array r:[ -> 2, -> 3 ] ~separator ' - ' )...
026| println( ~msg join( ~array r:[ -> 2, -> 3 ] ~separator ' - ' ):'2 - 3' )...
027|end
024|while (l{'count'}:sub (  )...
051| return this{'ncount'}:2
024|while (l{'count'}:sub (  ):-> 2 != 0):true
025| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> [ -> Null, -> [ -> 5, -> 6 ] ], -> [ -> 3, -> 4 ] ]
037|  this{'head'}[1]:[ -> Null, -> [ -> 5, -> 6 ] ] := rt[1]:[ -> Null, -> [ -> 5, -> 6 ] ]
038|  this{'ncount'}:1 = (this{'ncount'}:2 - 1):1
040|  if (this{'ncount'}:1 == 0):false
041|  end # if
047|  return rt[2]:[ -> 3, -> 4 ]
025| r = l{'pop'}:sub (  ):-> [ -> 3, -> 4 ]
026| println( ~msg join( ~array r:[ -> 3, -> 4 ] ~separator ' - ' )...
026| println( ~msg join( ~array r:[ -> 3, -> 4 ] ~separator ' - ' ):'3 - 4' )...
027|end
024|while (l{'count'}:sub (  )...
051| return this{'ncount'}:1
024|while (l{'count'}:sub (  ):-> 1 != 0):true
025| ... = l{'pop'}:sub (  )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> Null, -> [ -> 5, -> 6 ] ] )...
033|  if  not defined( ~arg this{'head'}[1]:[ -> Null, -> [ -> 5, -> 6 ] ] ):1
034|  end # if
036|  rt := this{'head'}[1]:[ -> Null, -> [ -> 5, -> 6 ] ]
037|  this{'head'}[1]:Null := rt[1]:Null
038|  this{'ncount'}:0 = (this{'ncount'}:1 - 1):0
040|  if (this{'ncount'}:0 == 0):true
041|   this{'tail'}:[ -> Null, -> Null ] := this{'head'}:[ -> Null, -> Null ]
041|  end # if
047|  return rt[2]:[ -> 5, -> 6 ]
025| r = l{'pop'}:sub (  ):-> [ -> 5, -> 6 ]
026| println( ~msg join( ~array r:[ -> 5, -> 6 ] ~separator ' - ' )...
026| println( ~msg join( ~array r:[ -> 5, -> 6 ] ~separator ' - ' ):'5 - 6' )...
027|end
024|while (l{'count'}:sub (  )...
051| return this{'ncount'}:0
024|while (l{'count'}:sub (  ):-> 0 != 0):false
027|end # finish loop
031|print( ~msg '*** eof stack test ***' )...


</pre>
</html>
</body>
