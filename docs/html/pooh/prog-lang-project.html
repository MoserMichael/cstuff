<hr />
<p>layout: post<br />
title:  Next project, The Pooh programming language<br />
<del>-</del></p>
<h2>{{ page.title }}<br />
<p class="publish_date">8 November 2011</p></h2>
<p>I want a new tinker project, so a scripting language will be created. The project will be presented as a series of articles; the first article will define the language in some detail.</p>
<p>First the name; It will be the &#8216;Pooh programming language&#8217; ; I think that if there is a Python in honor of Monty, then there should be a Pooh in honor of Pooh, so to speak, this is a long missing detail, so I will strive to correct it ;-)</p>
<p>The &#8216;Pooh programming language&#8217; will be an <a href="http://en.wikipedia.org/wiki/List_of_educational_programming_languages">Educational programming language</a> its purpose is to introduce kids to programming;</p>
<h3>General observations on the subject of (educational) programming languages</h3>
<p>For me, the practice of programming mainly consists of building bridges / translations between different concepts. Very often information has to be extracted from one source (be it some textual or binary language, or <span class="caps">GUI</span> toolkit that receives input from a real person) also very often some existing logical formalism is used to to access structured storage (<span class="caps">SQL</span> comes to mind),</p>
<p>What I like about scripting languages is that they make it easy to create bridges between different concepts, bridges that map the concepts directly into features of the scripting language; into combinations of easy to grasp structures like hashes and dynamic arrays &#8211; those can be combined into very elaborate structures.</p>
<p>An example of such a bridge between concepts is an <span class="caps">XML</span> parsing tool; the <a href="http://search.cpan.org/~grantm/XML-Simple-2.18/lib/XML/Simple.pm">Perl module <span class="caps">XML</span>::Simple</a> (the idea has been adapted into other scripting languages like <a href="http://xml-simple.rubyforge.org/">Ruby <span class="caps">XML</span>::Simple</a>  or <a href="http://groovy.codehaus.org/Reading+XML+using+Groovy&#39;s+XmlSlurper">Groovy XmlSlurper</a>  ) <span class="caps">XML</span> is a structured way of expression information; data in this format is magically translated into nested hashes that map tag names to the <span class="caps">XML</span> tree contained by that tag, <span class="caps">XML</span> attributes are mapped to name value pairs within the hash map that corresponds to a tag.</p>
<p>This way of looking at <span class="caps">XML</span> is a simplification of sorts, but it is much easier to work with the data this sway rather than working with the <a href="http://www.w3.org/DOM/">standard <span class="caps">DOM</span> <span class="caps">API</span></a> ;</p>
<h3>Historical justification &#8211; why is a new language needed</h3>
<p>In the eighties computers where much simpler; the programming languages available on a home computer would be various types of Basic; Logo and Assembly for serious developers; These languages were easier to master; partly by intent of their design; partly because of the limitation of the computer platform &#8211; for example, a mini computer could not have run the whole smalltalk environment or act as a Lisp machine.</p>
<p>Limited computers could run only simple languages &#8211; so paradoxically the barrier of entry (into programming) was lower with simple machines.</p>
<p>Also the limitations of the machine meant that one could do meaningful projects (by the standard of the day) with fewer means; When I was in High school, I was given a home computer as present; now it did not have any games  on it and for me it was difficult to get them; so I learned how to do my own computer games that went quite well.</p>
<p>What happened during later years? With the advent of Windows, schools switched to teach <a href="http://en.wikipedia.org/wiki/Computer_literacy">basic computer literacy skills</a> like using Word and Excel;   <br />
Not every household had a PC, so teaching the skill of using a word processor was regarded as a significant preparation for adult life. Also programming might have lost its importants, as some societies thought that they were entering a post industrial age where financial services were more important that productive activity, but that is a digression of sorts.</p>
<p>Also programming languages got more complicated; Serious langauges like C++ are notoriously hard to master; Java still is too complicated and verbose for teaching basic concepts. Scripting languages like Perl, Python and Ruby have lots of features; far too many; even Visual Basic is hard to compare with simple Basic dialects.</p>
<p>Things lacking in old Basic dialects that where added in more powerfull scripting languages are variable scope, hashes, dynamic arrays, references, objects, regular expressions, closures. The designers of Basic probably thought that it is essential to cut all these features out, in order to have a language that is easily taught / simple to acquire; I think it is still a challenge is to create a language that combines these goodies but that still remains simple;</p>
<p>There are still some relatively simple languages left &#8211; Squeak; Javascript; Logo. A problem with them is that the only practical usage of these languages is from their own environment, Logo is good for moving &#8216;turtles&#8217; and playing with words; trie to use it for something else&#8230;</p>
<p>So there seems to be a place for some simple scripting language that <br />
makes it easy to introduce programming<br />
is versatile enough to do real / interesting projects on real systems.</p>
<p>For scripting languages its is very important te be versatile; be usable in a multitude of different situations and from varying environments. As <a href="http://dobbse.net/thinair/2006/06/play-nice.html">observed here</a></p>
<blockquote>
<p>&#8230; Smalltalk&#8217;s weakness is &#8220;at the boundaries:&#8221; when you want to try to do some typical unix system maintenance, or interfacing with underlying C libraries, or something similar. As long as you&#8217;re staying within the Smalltalk environment, it completely rocks. But it&#8217;s definitely painful if you try to reach outside. And it&#8217;s especially painful if you want your code to work with different Smalltalks. What Perl got right was making it completely painless to integrate with its environment  &#8211;  In some sense <span class="caps">LISP</span> wants to be on a <span class="caps">LISP</span> Machine and Smalltalk wants to be in its virtual machine, whereas Perl wants to go out and play with the other kids. The former languages are introverted and Perl is extroverted.</p>
</blockquote>
<p>General purpose scripting languages have to cram in a lot of features; often design decissions are made with the aim to simplify the runtime interpreter / execution envionment, these tradeoffs tend to be counter intuitive / hard to explain; Examples of such tradeoffs made by some languages are &#8211; function variables are by default global unless declared as of local scope; values can be used before having been assigned a value; <br />
With an educational programming language one should strive to avoid such trade offs.</p>
<h3>What should be the user experience</h3>
<p>The Pooh language should come with some basic interactive environment &#8211; like a <span class="caps">REPL</span> where one can  edit the program and try out its parts as they are written. The environment must be friendly to bottom up software construction; one should be able to start with low level functionality, try it out and then work upword and use the simple parts to construct more complicated things.</p>
<p>It must be possible to integrate the environment into &#8216;software laboratories&#8217; suited for a particular purpose. Each &#8216;software laboratory&#8217; should integrate into a different environment; One such labority can be a tool that implements a two dimentional plane with moving sprite objects; the Pooh language would then be used to script the movement of the sprites, react to collisions or to additional input from the user ;  A different laboratory can be aimed at construction three dimensional objects scenes out of simple geometric figures; yet another &#8216;software laboratory&#8217; can deal with grammars and parsing text with various means</p>
<p>The idea is that programming language becomes embedded into multiple possible spaces; so the program would manipulate concepts from its concept space. I think that an educational programming language also requires that the developer environment for the language can be plugged into different applications.</p>
<h3>Language design principles</h3>
<p>The design principles for the Pooh programming language &#8211; favour code readability over brevity of notation; leave out complex features that can be left out, those that exist for &#8216;programming in the large&#8217; etc. Do not make tradeoffs that sacrifice ease of use against efficiency; still try to be efficient ; take the best features from other langauges while avoid things that suck.</p>
<h3>Short summary of features to steal from other languages</h3>
<p>And so it goes that most programming languges (especially scripting languages) are created by means of adapting / stealing features from previous programming languages.</p>
<h4>these are a few of my favorite things:</h4>
<ul>
	<li>Bash,Scheme: script debugging with <em>set -x</em> modes ; for a small program it is easier to debug by viewing a trace of the program execution, rather than to work with a debugger.</li>
	<li>Perl: Strict mode &#8211; the compiler checks that a variable/function is actually defined before using it. I think that some level of syntax checking is of benefit ; misspelled identifiers should not create runtime errors &#8211; it is easier to catch these errors during compilation.</li>
	<li>Function calls with <a href="http://">Named parameters</a> en.wikipedia.org/wiki/Named_parameter  ; various languages offer named parameters as an additional means of calling a function; I think that this should be the only way to call a function; It is much easier to read code that calls functions with named parameters; alas the notation for function calls is less compact.</li>
	<li>Python: the for loop construct / generator functions used in for loops (yield statement)</li>
	<li>Javascript: objects system by means of creating hash collections (prototypes)</li>
	<li>Lua: like the basic <em>syntax</em> of the language &#8211; no major anoyances there; In Lua I don&#8217;t like that variable scope in function defaults to global.</li>
	<li>Ruby: Qualified identifiers (I don&#8217;t like the choice of characters for prefix, but there should be some way of saying that an identifier refers to a class member or to a global variable) ; by default a variable in a function should be of local scope &#8211; what is done most frequently should be the shortest form; other options should be more explicit.</li>
	<li>Perl/Javascript/Python/Ruby/Lua: Syntax to declare a collection object and populate it with data</li>
	<li>Here documents: they should be similar to how <a href="http://search.cpan.org/~mjd/Text-Template-1.45/lib/Text/Template.pm">Text::Template   <br />
Perl module</a>  defines template text. Should be possible to treat a string as a Here document (templates)</li>
	<li>C++11: The new raw string literal (R&quot;aaaa&quot;) that manages to work without any escape characters at all !</li>
	<li>Perl: The way that  <a href="http://www.oopweb.com/Perl/Documents/PerlDoc/Volume/pod/perlfunc.html">Perlfunc / Perl Functions by  lCategory</a>  documents standard library functionality in a way similar to the Roget&#8217;s thesaurus.</li>
</ul>
<h4>Things that I particularly dislike</h4>
<ul>
	<li>Forcing to teach object orientation right from the start, just because everything is an object. I think that teaching object orientation right from the start is confusing (not just me here ).</li>
	<li>Ambiguous rules; for example call-by-sharing is ambiguous (which is used in most scripting languages); Ambiguous operators that do stuff depending on he type of operands (example assignment with values and object references); overloaded functions create ambiguity, these all can be powerful and confusing tools.</li>
	<li>Overriding + as string concatenation and addition was a really bad thing to do for javascript.</li>
	<li>C style syntax;  forced use of semicolon to finish a statement ; In particular I don&#8217;t like for loop syntax in C. (too many functionality in one line, assignment of index, loop invariant checking and modification of loop index in one line). One could do better with foreach + generator functions ; also things to cut are auto-increment <ins>+ and shortcut (</ins>=) operators; switch statement &#8211; all of them can be left out.</li>
	<li>Python: indentation has special meaning, just can&#8217;t get used to this.</li>
	<li>Arrays &#8211; for a beginner it is easier to have an array indexed from one onward (rather than zero) &#8211; without ways to feature to override this way of indexing; It is easier to reason about things as the first element of a sequence, etc; rather than zeroth case of prove by induction, first case of prove by induction. Basic and Lua do array indexing from one onward (alas one can override this); Python, Perl, Javascript, C, Pascal, Algol all start with 0.</li>
	<li>Javascript/Perl/Lua: the var/my keywords; assigning a variable in a function results in a new global unless you have declared the local with the var keyword; I think that this is very counter intuitive to have global scope by default.</li>
	<li>Perl,Basic: variable prefix (suffix) for type of variable; the type of a variable should become evident from the way the variable is used.</li>
	<li>Perl: References and explicit dereferencing of references</li>
	<li>Modules and namespaces, they are necessary for building libraries, but well, could one still possibly do without them &#8211; for an introduction to programming that is ?</li>
	<li>Exception feature in scripting languages &#8211; I think this tool is too heavy; also most scripts (and most programs) only bail out on error and do not have to do complex error recovery sequences.</li>
	<li>Operator overloading in scripting languages &#8211; keeps you guessing about the meaning of an operator, does not increase readability; Javascript can do without this feature.</li>
	<li>I don&#8217;t like it when there are many many ways to do a string literal; but <span class="caps">HERE</span> documents are great</li>
	<li>I don&#8217;t like escape sequences in string literals</li>
	<li>Identifier names &#8211; in many languages identifier names consist of letters, digits and underscores. I think that this is too limiting.</li>
	<li>Level of detail in error messages is mostly often awful.</li>
	<li>All of them: Hash tables with complex keys &#8211; keys that are not strings. Ideally a hash should be able to store any object as key; well Python solves this problem by introducing <a href="http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences">tuples</a>  &#8211; read only sequences can be key to a hash; which results in the introduction of yet another entity. Perl does not bother with this problem &#8211; if you insert a Array as key, then it just casts its to scalar &#8211; takes the length of the array as key that is; not very intuitive either. I think one could do better than that.</li>
</ul>
<h4>Things that I don&#8217;t know how to eat</h4>
<ul>
	<li>Regular expressions; it seems clear that a scripting language must have some form of regular expression; all was well and clear until they invented <a href="http://en.wikipedia.org/wiki/Perl_6_rules">Perl6 rules</a> or Perl5 <a href="http://search.cpan.org/~dconway/Parse-RecDescent-1.966_000/lib/Parse/RecDescent.pm"> Parse::RecDescent module</a> ; now this features seems to come from <a href="http://www.snobol4.org/docs/burks/tutorial/ch4.htm">snobol   patterns</a></li>
	<li>Optional typing ; worth to bother if there is a <span class="caps">JIT</span> or compilation to native code.</li>
	<li>Perl: ties ; most scripting languages have some way to override certain aspects.<br />
Perl has <a href="http://perldoc.perl.org/perltie.html">ties</a> ;<br />
Lua has <a href="http://www.lua.org/manual/5.2/manual.html#2.4">metatables</a>  ; <br />
Python and Ruby have per class overrides, in python you do <a href="http://docs.python.org/reference/datamodel.html"><i><specialname></i> methods</a>  ; <br />
Currently Javascript does not have any of these features, and seems to do fine without them, for what it does.</li>
</ul>
<h4>Plain problems</h4>
<ul>
	<li>Shells, Perl: Separate comparison operators for numeric and string values. Perl inherits separate string comparison operators from the <span class="caps">UNIX</span> shells. In Lua and Javascript one does not have them &#8211; here if a string is compared with a number, then the number is treated as a string;  Unfortunately it becomes much more difficult to infer the type of variables this way; also numeric and string comparison is not the same !</li>
	<li>Same problem goes for arithmetic operators ; what should happen when adding a string to an number;</li>
</ul>
<h3>General Terms / General requirements.</h3>
<p>This section spells out the general requirements for the Pooh programming language in more detail.</p>
<p>(GR1) Language must serve an educational purpose / be suited for the purpose of introducing kids to <br />
programming; it is a procedural language; that means that its has assignments.</p>
<p>(GR2) The syntax may not force the user to perform repetitive tasks over and over again ; For example it may not require the user to put in semicolon delimiter between statements &#8211; that&#8217;s an  evil; or it should not require the user to declare variables / types of variables.</p>
<p>I think that C and languages with a syntax similar to C are too terse and cryptic for beginners. On the other hand it should be a bit less verbose than Pascal.</p>
<p>(GR3) It must be possible to read the code &#8211; meaning that it is essential to be able to understand what a line of code does; no &#8216;Under the scene&#8217; actions like nested construction/destruction, operator <br />
overloading, no macros (never), No advanced looping construct that does assign an initial value to index, check the exit condition on index and pass to next iteration in one line (like for in C);</p>
<p>(GR4) There is some support for object orientation; Object orientation via prototypes (like javascript / Self) is supported; one can have objects by means of closures.<br />
Please see <a href="../07/feature-oo.html">oo feature</a></p>
<p>(GR5) Be fun to use. It is very difficult to quantify this or to give a definition for this concept, but we will try: <br />
1. Encourage data driven programming / it must be possible to declare complex lists / hashes in code / Nesting of hashes and lists;<br />
2. Encourage bottom up software construction / exploratory programming;   (That means we need a <span class="caps">REPL</span>)<br />
3. Quickest way of debugging should be by means of a built in tracing facility. Here we learn from other languages, like in Korn/Bash shells we have set -x; in Chez Scheme there is also a very strong built in trace facility.<br />
4. If there is a syntax error, it should be clear what it means.</p>
<p>(GR6) Must have a wide field of application; must be able to serve as a scripting language (must not be the most efficient one for that purpose);  One should get the impression of learning something tangible.</p>
<p>(GR7) Error message must be very detailed and helpful.</p>
<h3>Defining the Pooh language in some more detail</h3>
<p>(R1) Language must not have strong typing, this would introduce too many compiler errors; the language should</p>
<p>(R2) functions are &#8216;first class&#8217; &#8211; meaning that we have anonymous functions, and <br />
functions can be returned as return values, etc.</p>
<p>(R3) A value may have one of the following types<br />
scalar, with numeric value type<br />
scalar, with string value type<br />
scalar, with lambda value (reference to function)<br />
dynamic array<br />
hash</p>
<p>(R4) Variable binding is created either by assignment (by assigning a value to a variable) or by parameter declaration;</p>
<p>(R3) The following situations should result in compilation error  &#8211; use of parameter that has  not been defined  (variables are declared by assigning a value to a name) ; call of function that has not been declared; passing a parameter that is not used by a function. These checks will will be similar to <span class="caps">STRICT</span> mode in Perl &#8211; these checks are mandatory and cannot be turned off.</p>
<p>(see more in <a href="../07/feature-typecheck.html">type checking feature</a></p>
<p>(R4) do not have to define the type of a variable; it will become obvious from how the variable is later used; if a variable is used as an array (a[ 0 ] = 0 ), then a is  an array; the same variable name can not be later used as if it were a scalar. Problem: it is not always possible to tell the type of a binding: If you insert something into an array / hash, then later access to this entry is untyped and must be checked at <br />
run time;</p>
<p>General principle: If you can infer the type of something during parsing/compilation then do so, if you can&#8217;t then defer type check to run time (&#8216;somewhat&#8217; dynamically typed)</p>
<p>(R5) Semantics of values;</p>
<p>Please see <a href="../07/feature-values.html">values feature</a> for a detailed discussion of the topic.</p>
<p>(R6) Functions have prototypes; One function can have one prototype (no overloading); The prototype defines the names of the parameters, type of parameters is derived/infered from usage of parameter.</p>
<p>Please see <a href="../07/feature-functions.html">function feature</a></p>
<p>(R7) Parameter passing / Evaluation strategy.</p>
<p>Please see <a href="../07/feature-functions.html">function feature</a></p>
<p>(R11) Check function prototype on call: If function is called directly then check number of parameters and if their types match (for example check if scalar is not passed instead of an array); If type is difficult to establish (function reference stored in hash) then defer check to run time; the type of a parameter is determined by how it is used (very simplistic form of type inference)</p>
<p>(R6) Operators should strictly have one meaning; I don&#8217;t like operators where the meaning depends on the type operand types.</p>
<ul>
	<li>There are numeric comparison operators: &lt;&gt;  , == ,  &gt; , &lt;  , &gt;= , &lt;= ; <br />
Numeric operators  + , &#8211; , * , / , %<br />
For these operators the operands must be of numeric type; the operand may not be a hash, dynamic array or function type.</li>
</ul>
<ul>
	<li>There are string comparison operators:  ne , eq , gt , lt , le , ge &#8211; here both operands must be string values.</li>
</ul>
<ul>
	<li>String concatenation operator ..<br />
For these concatenation operator, the operands may any typ; a numeric value will be turned to string value implicitly.  The values of an array will be printed with spaces between values; hash table will be formated in a simple manner.</li>
</ul>
<p>(R14) Reflection, will be done as a library, so no need for special syntactic constructs here.</p>
<p>(R12) Co-routines / will have generator functions with yield; *must have for nice iteration *;<br />
<a href="../07/feature-threads.html">more on threads</a></p>
<p>(R13)  Things to cut: exceptions, namespaces, classes (also cuts Generic types, so the innovation of doing without classes :really makes things much more feasible); no macros / no meta programming at all; No blocks as function closures (this feature might add to more concise code, but is very confusing &#8211; is it a statement? Is it a function? ) ; no syntax that does many things at once &#8211; like for statements in C;</p>
<p>(R15)  Also one needs array slices in order to return multiple variables from functions.</p>
<p>(R16) String literals; <br />
Please see <a href="../07/feature-string-literals.html">string literals</a></p>
<p>(R17) Keys to hash tables<br />
Please see &#8220;complex hash keys&#8221;../07/feature-complex-hash-keys.html</p>
