<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Simple tools for multi threading / objects in plain C: tpool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simple tools for multi threading / objects in plain C&#160;<span id="projectnumber">Snapshot</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tpool.h File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="a00011_source.html">tutils/tqueue.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="a00007_source.html">tutils/cbarrier.h</a>&gt;</code><br/>
</div>
<p><a href="a00009_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">tagRUNNABLE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">an interface to run a unit of work.  <a href="a00002.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">tagTHREADPOOL</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a thread pool with fixed number of worker threads.  <a href="a00003.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#af16d7d96e7ed5b618a81394d68de79e4">RUNNABLE_HANDLER</a> )(struct <a class="el" href="a00002.html">tagRUNNABLE</a> *request)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00002.html">tagRUNNABLE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a3f3ff8a5ef0014f681395dda3e8e5ca6">RUNNABLE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">an interface to run a unit of work.  <a href="#a3f3ff8a5ef0014f681395dda3e8e5ca6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00003.html">tagTHREADPOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a23469035543918e40160a7c520fa4cac">THREADPOOL</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a thread pool with fixed number of worker threads.  <a href="#a23469035543918e40160a7c520fa4cac"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a26254071747a14c26402a397d3766f9f">RUNNABLE_init</a> (<a class="el" href="a00002.html">RUNNABLE</a> *runnable, <a class="el" href="a00009.html#af16d7d96e7ed5b618a81394d68de79e4">RUNNABLE_HANDLER</a> handler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a RUNNABLE instance  <a href="#a26254071747a14c26402a397d3766f9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00003.html">THREADPOOL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a7b909aed828b50e11051b9147aebb82f">THREADPOOL_init</a> (<a class="el" href="a00009.html#af16d7d96e7ed5b618a81394d68de79e4">RUNNABLE_HANDLER</a> process_result, int queue_size, int num_threads, int stack_size_kb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a thread pool and starts it.  <a href="#a7b909aed828b50e11051b9147aebb82f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ad367dbd16ee8e8924423fdd0a8e737f3">THREADPOOL_close</a> (<a class="el" href="a00003.html">THREADPOOL</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a47bed275260b9a13f7ccc2b1fbe8c76a">THREADPOOL_send_block_on_queue_full</a> (<a class="el" href="a00003.html">THREADPOOL</a> *pool, <a class="el" href="a00002.html">RUNNABLE</a> *request)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">posts a work request to the pool; blocks if request queue limit is reached  <a href="#a47bed275260b9a13f7ccc2b1fbe8c76a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ac119ddd51197dc5e0d8e709f3994a5ae">THREADPOOL_send_fail_on_queue_full</a> (<a class="el" href="a00003.html">THREADPOOL</a> *pool, <a class="el" href="a00002.html">RUNNABLE</a> *request)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">posts a work request to the pool; blocks if request queue limit is reached  <a href="#ac119ddd51197dc5e0d8e709f3994a5ae"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a3f3ff8a5ef0014f681395dda3e8e5ca6"></a><!-- doxytag: member="tpool.h::RUNNABLE" ref="a3f3ff8a5ef0014f681395dda3e8e5ca6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00002.html">tagRUNNABLE</a>  <a class="el" href="a00002.html">RUNNABLE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>an interface to run a unit of work. </p>
<p>Acts as a work request for thread pool Includes a callback that is invoked in order to process the request.</p>
<p>Very similar to java concept of java.lang.Runnable. </p>

</div>
</div>
<a class="anchor" id="af16d7d96e7ed5b618a81394d68de79e4"></a><!-- doxytag: member="tpool.h::RUNNABLE_HANDLER" ref="af16d7d96e7ed5b618a81394d68de79e4" args=")(struct tagRUNNABLE *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="a00009.html#af16d7d96e7ed5b618a81394d68de79e4">RUNNABLE_HANDLER</a>)(struct <a class="el" href="a00002.html">tagRUNNABLE</a> *request)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00009_source.html#l00012">12</a> of file <a class="el" href="a00009_source.html">tpool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a23469035543918e40160a7c520fa4cac"></a><!-- doxytag: member="tpool.h::THREADPOOL" ref="a23469035543918e40160a7c520fa4cac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00003.html">tagTHREADPOOL</a>  <a class="el" href="a00003.html">THREADPOOL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>a thread pool with fixed number of worker threads. </p>
<p>The pool has a request queue: New requests are enqueued into it, the worker threads dequeue a work request and invoke the 'run' method of work request.</p>
<p>One creation of thread pool the following parameters are specified</p>
<ul>
<li>number of worker threads in thread pool.</li>
<li>maximum number of entries in request queue (or -1 if number of requests is unlimited).</li>
</ul>
<p>It is very important to set a reasonable size limit on the request queue; An unlimited queue can often lead to out of memory conditions: If work requests arrive at a rate faster than what can be processed, a bounded request buffer guards against a situation where the system is run at a load rate that is higher then it's capacity.</p>
<p>In this situation the request queue acts as a bounded buffer; it should be able to account for temporary fluctuations of the load; it can accomodate temporary peaks (i.e. short periods of time when the load is higher then the peak load), on condition that the request load later falls back to normal.</p>
<p>You might find this class similar to java class java.util.concurrent.ThreadPoolExicutor when used with a thread pool size. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a26254071747a14c26402a397d3766f9f"></a><!-- doxytag: member="tpool.h::RUNNABLE_init" ref="a26254071747a14c26402a397d3766f9f" args="(RUNNABLE *runnable, RUNNABLE_HANDLER handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RUNNABLE_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html">RUNNABLE</a> *&#160;</td>
          <td class="paramname"><em>runnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00009.html#af16d7d96e7ed5b618a81394d68de79e4">RUNNABLE_HANDLER</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructs a RUNNABLE instance </p>

<p>Definition at line <a class="el" href="a00008_source.html#l00008">8</a> of file <a class="el" href="a00008_source.html">tpool.c</a>.</p>
<div class="fragment"><pre class="fragment">{
   runnable-&gt;<a class="code" href="a00002.html#a127e2ce895ac78923ce28190c1c793f9">handle_request</a> = handler;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad367dbd16ee8e8924423fdd0a8e737f3"></a><!-- doxytag: member="tpool.h::THREADPOOL_close" ref="ad367dbd16ee8e8924423fdd0a8e737f3" args="(THREADPOOL *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void THREADPOOL_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">THREADPOOL</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00008_source.html#l00073">73</a> of file <a class="el" href="a00008_source.html">tpool.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i;

  <span class="keywordflow">for</span>( i=0; i &lt; pool-&gt;<a class="code" href="a00003.html#a0bbc9bfb92f691411651c63f2de40465">num_threads</a>; i++) {
    <a class="code" href="a00010.html#ae792121619b59c4ee95afbc8f3ccfc3f" title="push out of order exit message (null message at top of queue)">TQUEUE_push_exit_message</a>( &amp;pool-&gt;<a class="code" href="a00003.html#a4b67f6780a55d06dda8ad7f893b0b95b">request_queue</a>);
  }
  <a class="code" href="a00006.html#a60330e74834b5137fd27b8e3ea68351b" title="All threads call this function, nobody continues untill all have called this function.">CYCLIC_BARRIER_await</a>( &amp;pool-&gt;<a class="code" href="a00003.html#a57ebff173542131630ab9542df496a2a">all_finished</a> );
  free(pool);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7b909aed828b50e11051b9147aebb82f"></a><!-- doxytag: member="tpool.h::THREADPOOL_init" ref="a7b909aed828b50e11051b9147aebb82f" args="(RUNNABLE_HANDLER process_result, int queue_size, int num_threads, int stack_size_kb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html">THREADPOOL</a>* THREADPOOL_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00009.html#af16d7d96e7ed5b618a81394d68de79e4">RUNNABLE_HANDLER</a>&#160;</td>
          <td class="paramname"><em>process_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stack_size_kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructs a thread pool and starts it. </p>
<p>The method</p>
<ul>
<li>creates request queue</li>
<li>runs fixed number of worker threads</li>
</ul>
<p>The worker thread</p>
<ul>
<li>fetches a work request from the request queue</li>
<li>invokes the handle_request callback stpred in the work request</li>
<li>if process_result callback has been registered: invokes process_result callback (in order to have common policy of processing the results).</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">process_result</td><td>a callback that receives work request after invoking it's run method. Value can be 0 (in this case it is not invoked) </td></tr>
    <tr><td class="paramname">queue_size</td><td>limit on the request queue (for details see THREADPOOL ) </td></tr>
    <tr><td class="paramname">num_threads</td><td>number of worker threads </td></tr>
    <tr><td class="paramname">stack_size_kb</td><td>Size of thread pool stack in kilobytes (-1 if default stack size) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00008_source.html#l00034">34</a> of file <a class="el" href="a00008_source.html">tpool.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="a00003.html" title="a thread pool with fixed number of worker threads.">THREADPOOL</a> *pool;
  pthread_t pth;
  pthread_attr_t attr;
  <span class="keywordtype">int</span> i, rt;

  pool = (<a class="code" href="a00003.html" title="a thread pool with fixed number of worker threads.">THREADPOOL</a> *) malloc( <span class="keyword">sizeof</span>(<a class="code" href="a00003.html" title="a thread pool with fixed number of worker threads.">THREADPOOL</a>) );
  <span class="keywordflow">if</span> (!pool) {
    <span class="keywordflow">return</span> 0;
  }

  pool-&gt;<a class="code" href="a00003.html#a135b256b03a34d96456263b584bbddcf">process_result</a> = process_result;
  pool-&gt;<a class="code" href="a00003.html#a0bbc9bfb92f691411651c63f2de40465">num_threads</a> = num_threads;

  <a class="code" href="a00010.html#a4ae0a31bb2c0162bd58249e5a57a5af9" title="create new queue">TQUEUE_init</a>( &amp;pool-&gt;<a class="code" href="a00003.html#a4b67f6780a55d06dda8ad7f893b0b95b">request_queue</a>, queue_size );

  pthread_attr_init( &amp;attr );
  pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_DETACHED );
  pthread_attr_setstacksize( &amp;attr, stack_size_kb * 1024 );

  <span class="keywordflow">for</span>( i = 0; i &lt; num_threads; i++) {

     <span class="keywordflow">if</span> ((rt = pthread_create( &amp;pth, &amp;attr, <a class="code" href="a00008.html#adea6ef467308139cf432ac8bab181b3b">worker_thread</a>, pool ) )  != 0) {
        <span class="keywordflow">break</span>;
     }
  }
  <span class="keywordflow">if</span> ( i &lt; num_threads) {
     errorp(rt, <span class="stringliteral">&quot;Can&#39;t create thread # %d&quot;</span>, i);
     <a class="code" href="a00006.html#a0fc4eba3b18970f3e4e23d3db8c4f99d" title="initialises a new cyclic barrier">CYCLIC_BARRIER_init</a>( &amp;pool-&gt;<a class="code" href="a00003.html#a57ebff173542131630ab9542df496a2a">all_finished</a>, i + 1 );
     <a class="code" href="a00008.html#ad367dbd16ee8e8924423fdd0a8e737f3">THREADPOOL_close</a>( pool );
     <span class="keywordflow">return</span> 0;
  }

  <a class="code" href="a00006.html#a0fc4eba3b18970f3e4e23d3db8c4f99d" title="initialises a new cyclic barrier">CYCLIC_BARRIER_init</a>( &amp;pool-&gt;<a class="code" href="a00003.html#a57ebff173542131630ab9542df496a2a">all_finished</a>, num_threads + 1 );

  <span class="keywordflow">return</span> pool;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a47bed275260b9a13f7ccc2b1fbe8c76a"></a><!-- doxytag: member="tpool.h::THREADPOOL_send_block_on_queue_full" ref="a47bed275260b9a13f7ccc2b1fbe8c76a" args="(THREADPOOL *pool, RUNNABLE *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int THREADPOOL_send_block_on_queue_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">THREADPOOL</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">RUNNABLE</a> *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>posts a work request to the pool; blocks if request queue limit is reached </p>
<p>A request is always queued. If request queue limit is reached then this method blocks until the size of the queue falls back, In this case the request is enqueued and this method returns.</p>
<p>Returns 0 on success, -1 on failure (can't allocate memory for request) </p>

<p>Definition at line <a class="el" href="a00008_source.html#l00084">84</a> of file <a class="el" href="a00008_source.html">tpool.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="a00010.html#ab61172de6cf3a4f11122696a48665c1b" title="add new entry to queue, block if maximum queue limit has been reached">TQUEUE_push_block_on_queue_full</a>( &amp;pool-&gt;<a class="code" href="a00003.html#a4b67f6780a55d06dda8ad7f893b0b95b">request_queue</a>, request);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac119ddd51197dc5e0d8e709f3994a5ae"></a><!-- doxytag: member="tpool.h::THREADPOOL_send_fail_on_queue_full" ref="ac119ddd51197dc5e0d8e709f3994a5ae" args="(THREADPOOL *pool, RUNNABLE *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int THREADPOOL_send_fail_on_queue_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00003.html">THREADPOOL</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00002.html">RUNNABLE</a> *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>posts a work request to the pool; blocks if request queue limit is reached </p>
<p>A request is queued if the request queue did not reach its size limit. If request queue limit is reached then this method returns an error.</p>
<p>Returns 0 on success, -1 on failure </p>

<p>Definition at line <a class="el" href="a00008_source.html#l00089">89</a> of file <a class="el" href="a00008_source.html">tpool.c</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="a00010.html#a371657b010acd669b760f72307d7ab99" title="add new entry to queue, fail if maximum queue limit has been reached">TQUEUE_push_fail_on_queue_full</a>( &amp;pool-&gt;<a class="code" href="a00003.html#a4b67f6780a55d06dda8ad7f893b0b95b">request_queue</a>, request);
}
</pre></div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Aug 23 2011 18:31:27 for Simple tools for multi threading / objects in plain C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
