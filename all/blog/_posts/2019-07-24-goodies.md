---
layout: post
title: Goodies
---

{{ page.title }}
----------------

<p class="publish_date">
24 July 2019
</p>

From time to time there are some goodie scripts that I would like to share; 
(actually i put up my environment + some more goodies for bash scripting [here](https://github.com/MoserMichael/myenv) )
Maybe you might find something interesting within this collection:

Other variants of grep (that's seems to be my main occupation throughout the day ;-)
Even doing a combination of find / xarg / grep is a science all by itself - if you find a file with a space it it then it will be skipped.
find -print0 terminates each line with a 0 character, but then yo have to tell xargs -0 to get it back.
Everything so damn complicated.

<blockquote>
    <code><pre>
# grep in cpp sources
s()
{
  find . -type f \( -name '*.cpp' -o -name '*.cxx' -o -name '*.hpp' -o -name '*.hxx' -o -name '*.h' \) -print0 2>/dev/null | xargs -0 grep $*
}

# grep in python files
p()
{
  find . -name '*.py' -print0 2>/dev/null | xargs -0 grep $*
}
    </pre></code>
</blockquote>

Building of ctags file, again doing that in the repo root (to get all files); ctags has quite an involved command line all by itself.

<blockquote>
    <code><pre>
# build ctags
ctg()
{
  # find the top level directory for this git repository
  TOP_DIR=`git rev-parse --show-toplevel 2>/dev/null`
  if [ "x$TOP_DIR" != "x" ]; then
      pushd $TOP_DIR >/dev/null
      rm tags 2>/dev/null
      find . -type f \( -name '*.cpp' -o -name '*.cxx' -o -name '*.hpp' -o -name '*.hxx' -o -name '*.h' \) -print 0 | xargs -0 ctags -a --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++   
      popd >/dev/null
  else 
        echo "$PWD is not a git repo"
  fi
}
    </pre></code>
</blockquote>

or the next function gitgrep - it always goes to the root directory of the current repository - also each search result shows the full path of the match.

<blockquote>
    <code><pre>
    gitgrep()                                                                                                                                                                                                                                     
{                                                                                                                                                                                                                                                 # find the top level directory for this git repository                                                                                                                                                                                    
    TOP_DIR=`git rev-parse --show-toplevel 2&gt;/dev/null`                                                                                                                                                                                       
    if [ "x$TOP_DIR" != "x" ]; then                                                                                                                                                                                                           
        pushd $TOP_DIR %gt;/dev/null                                                                                                                                                                                                             
        # search in all files, they are now relative to repo root dir; so prepend the repo dir to get full path                                                                                                                               
        git ls-files -z | xargs -0 grep $* | while IFS= read -r line; do printf '%s/%s\n' "$TOP_DIR" "$line"; done                                                                                                                           
                                                                                                                                                                                                                                              
        # no all the colors of git grep output are gone after pipng them through the next stage....                                                                                                                                           
        #git --no-pager grep $* | while IFS= read -r line; do printf '%s/%s\n' "$TOP_DIR" "$line"; done                                                                                                                                        
        popd &gt;/dev/null                                                                                                                                                                                                                       
    else                                                                                                                                                                                                                                      
        echo "$PWD is not a git repo"                                                                                                                                                                                                         
    fi                                                                                                                                                                                                                                        
}     
    </pre></code>
</blockquote>


Having the name of the git branch in the bash command prompt - quite essential if you are working with multiple branches, it helps to avoid some effort while working on the wrong branch.
Having the branch name without colors that's fine; but when you want colors with bash then things become messy.


<blockquote>
    <code><pre>
# Git branch in prompt.
parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

PS1="[\u@\h \W\$(parse_git_branch)]\$ "

# strange: when I log in with the color prompt, then I have to resource the shell, else git branch doesn't display.
#PS1="[\e[0;34m\u@\h\e[m \W\\e[0;35m$(parse_git_branch)\e[m]\$ "

# but don't need to do that with uniform coloring ... as awayls strange hickups upon non-trivial usage...
#PS1="[\e[0;35m\u@\h \W\$(parse_git_branch)\e[m]\$ "
    </pre></code>
</blockquote>


Another useful thing is find replace in multiple files: 
here [link](https://github.com/MoserMichael/myenv/blob/master/find-replace.sh) is a script that is supposed to take the pane out of this. Here is the help text

./find-replace.sh  -h
./find-replace.sh -s <source filter> -f <from> -t <to> [-v -h]

apply replace to multiple input ifles


<blockquote>
    <code><pre>
-s &lt;source filter&gt;      : specify input files; available values: cpp git go py shell 
-f &lt;from&gt;               : replace from
-t &lt;to&gt;                 : replace to
-r                      : report how many files were changed.

source filter runs find and then it pipes it into sed to replace it.
    </pre></code>
</blockquote>


or another one: who are the most frequent contributors in the current git repository?

<blockquote>
    <code><pre>
#
# who are the most frequent authors in the current git repository?
#
alias whoisauthor="git log | grep 'Author: ' | sort  | uniq -c | sort -k1rn | less"


    </pre></code>
</blockquote>

And now a command to delete everything from the local docker registry, so that one can start from scratch. 

<blockquote>    
    <code><pre>
    
# delete everything in docker registry 
dockerclean() 
{
    echo "*** stop all docker containers ***"
    docker stop $(docker ps -a -q)
    
    echo "*** delete all containers ***"
    docker rm -vf $(docker ps -a -q)

    echo "*** delete all imagess ***"
    docker rmi -f $(docker images -a -q)
}
    </pre></code>
</blockquote>
   
a script that checks if a topic is available in multiple man pages, if it is then it displays the list of available pages and prompts you for the desired page.

<blockquote>    
    <code><pre>
    
# if argument exists in one man page - call man &lt;argument&gt;                                                                                                                                                                                 
# if argument exists in more than one man page - promt user for a choice of man page, then call man with the argument                                                                                                                         
function h                                                                                                                                                                                                                                    
{                                                                                                                                                                                                                                             
    local sterm                                                                                                                                                                                                                               
    local tmpfile                                                                                                                                                                                                                             
    local mpages                                                                                                                                                                                                                              
    local mpagecount                                                                                                                                                                                                                          
                                                                                                                                                                                                                                              
    sterm=$*                                                                                                                                                                                                                                  
    tmpfile=$(mktemp /tmp/sshtonode.XXXXXX)                                                                                                                                                                                                       mpagecount=0                                                                                                                                                                                                                              
                                                                                                                                                                                                                                              
    for m in 1 2 3 4 5 6 7 8 9; do                                                                                                                                                                                                            
        man $m searchterm $sterm &gt;$tmpfile 2&gt;/dev/null                                                                                                                                                                                        
        fsize=$(stat --printf="%s" $tmpfile)                                                                                                                                                                                                  
        if [[ $fsize != 0 ]]; then                                                                                                                                                                                                            
            mpages="$mpages $m"                                                                                                                                                                                                               
            ((mpagecount += 1))                                                                                                                                                                                                               
        fi                                                                                                                                                                                                                                    
        rm -f $tmpfile                                                                                                                                                                                                                        
    done                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                              
    if [ $mpagecount == 0 ]; then                                                                                                                                                                                                             
       echo "* no page found *"                                                                                                                                                                                                               
    else                                                                                                                                                                                                                                      
       if [[ $mpagecount &lt; 1 ]]; then                                                                                                                                                                                                         
          echo "select page: $mpages"                                                                                                                                                                                                         
                                                                                                                                                                                                                                              
          local page                                                                                                                                                                                                                          
                                                                                                                                                                                                                                              
          echo -n "&gt; "                                                                                                                                                                                                                        
          read page                                                                                                                                                                                                                           
                                                                                                                                                                                                                                              
          man $page $sterm                                                                                                                                                                                                                    
       else                                                                                                                                                                                                                                   
          man $sterm                                                                                                                                                                                                                          
       fi                                                                                                                                                                                                                                     
    fi                                                                                                                                                                                                                                        
}    
    </pre></code>
</blockquote>

For tmux: the function ta takes a tmux session name as argument and attaches to it; now this one also does completion on the session name.

<blockquote>    
    <code><pre>

function ta {
    tmux attach -t $1
}

function _ta {
  local cur prev opts f
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  for f in $(tmux ls | awk '{ print $1 }'); do
    f=${f: : -1}
    opts="$opts $f" 
  done

  COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )  
  return 0
}   

complete -F _ta ta 

                                                                                                                                                                                                                                              
alias tls='tmux ls'                                                                                                                                                                                                                           
alias tn='tmux new -s'                                                                                                                                                                                                                        
alias tk='tmux kill-session -t'  

    </pre></code>
</blockquote>

also the setup.sh script (in the linked repo ) adds the [tmux-resurrect](https://github.com/tmux-plugins/tmux-resurrect) and [tmux-continuum](https://github.com/tmux-plugins/tmux-continuum) plugins to the current users setup; so that the sessions are autosaved/restored.
