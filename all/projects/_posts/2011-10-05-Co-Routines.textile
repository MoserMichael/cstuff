---
layout: post
title:  Simple co-routine package in C
---

h2. {{ page.title }}
<p class="publish_date">5 October 2011</p>

This project presents a simple user mode threading library, it turns out that this concept has many names 

"coroutine package":http://en.wikipedia.org/wiki/Coroutine 
"continuations":http://en.wikipedia.org/wiki/Continuation .
In the Windows world this concept is also called a "Fiber":http://en.wikipedia.org/wiki/Fiber_(computer_science) 
Also known as user mode multi threading
"coopereative multitasking":http://en.wikipedia.org/wiki/Computer_multitasking#Cooperative_multitasking.2Ftime-sharing 

It is a small wonder how so many computer science terms all denote the the very same concept. Usually a confused language is either a sign that the same concept has been reinvented several times, or that something is not very well understood, this fact is known since the times of Babylon. Lets see.

Software engineers try to create complex systems out of simple parts; each simple part implements some sequence of commands - a process of sorts. Let's look at a simple example; process (A) creates a sequence of fibonacci numbers, and process (B) receives each fibonacci number and computes the sum of the square roots of each fibonaci numbers.

Now one has two choices, either process (A) and process (B) share the same stack, or they do not share the same stack. 

<pre>
void make_fibonacci_sequence( uint64_t *fib, size_t num_fib ) 
{
  uint64_t a=0, b=1, n;
  size_t i;

  for(i=0; i < num_fib; i++, a = b, b = n) {
    n = a + b;
    fib[ i ] = n;
  } 
}

double sum_of_roots( uint64_t *num, size_t num_size ) 
{
  size_t i;
  double sum_roots = 0;

  for( i = 0; i < num_size; i++) 
    sum_roots += sqrt( (double) num[i] );
  return sum_roots;
}

int main()
{
  uint64_t num[MAX_NUM];
  
  make_fibonacci_sequence( num, MAX_NUM );
  printf("Sum of roots of fibonaci numbers: %f\n", sum_of_roots( num, MAX_NUM ) );
}
</pre>

In this example both steps share the same stack, first fibonacci numbers are computed and stored in an array by the first procedure, and then the result is passed to the second procedure that computes the sum of the square roots.

Now what if the array of results is very large and we are short on computer memory ? What if one has to know the current sum of square roots imedeately upon receiving a new fibonacci number / react to the event of a new fibonacci number?
In this situation both processes have to share the same stack, so that each new fibonacci number is passed to a callback function "callback function":http://en.wikipedia.org/wiki/Callback_(computer_programming) 

<pre>
typedef void (*FIBONACCI_CB) (uint64_t num, void *ctx);

void generate_fibonacci_sequence( size_t num_size, FIBONACCI_CB callback, void *ctx ) 
{
  uint64_t a=0, b=1, n;
  size_t i;

  for(i=0; i < num_size; i++, a = b, b = n) {
    n = a + b;
    callback( n, ctx );
  } 
}

void fibonacci_cb( uint64_t fib_num, void *ctx) 
{
   double *fibb_sum = (double *) ctx;
   *fibb_sum += sqrt( (double) fib_num );
}

int main()
{
  uint64_t num[MAX_NUM];
  double result = 0;
  
  generate_fibonacci_sequence( MAX_NUM, fibonacci_cb, &result );
  printf("Sum of roots of fibonaci numbers: %f\n", result );
}
</pre>
.
This mode of doing things has a marked disadvantage: The procedure of computing the sum of roots is now chopped up into multiple calls of the callback function fibonacci_cb ;  on each call this function has to retrieve the current state of the computation from the argument 'context parameter' , perform a processing step and then update the result back into the 'context parameter'. A more complex process also must be partinioned into a state machine, the state is maintained extra in the 'context parameter'. No fun.

So we need to have both processes running at the same time, and passing a message between them.
So each procedure needs its own stack. Now the same basic problem is being solved in a multitude of ways; each solution solves the problem for some specific context, 


multi processing: Two processes are connected via a pipe; the fibonacci number generator writes its result to the pipe; the square root additioner reads each numbrer off the pipe.
Multi-threading: 
actor model - several threads communicate via known queues; 
Python / Perl generator functions.


Now coroutine will simply maintain a stack per process, the fibonacci number generator has its own stack, the consumer of fibonacci numbers has its own stack. When a new number is computed, fibonaci number generator switches the stack to the consumer of numbers, when the consumer is ready and wants to get a new number then it switches the stack to the generator function.

There is a significant difference - with multiple threads or multiple processes it is the operating system that decides which task will run next; with coroutine the application decides when to switch between stacks.

h3. How to pass a typed typle of values around.

This library will be passing parameters from and to the coroutine thread, so here is a utility class in C for packaging of a typed set of values.

<pre>
#include <corothread/val.h>

VALUES values; 

uint8_t n8 = 250, _n8;
uint16_t n16 = 65000, _n16;
int32_t  n32 = 42, _n32;
int64_t n64 = 0xBEEFBEEFBEEFBEEF, _n64;
char *sval = "aaa", *_sval;

VALUES_init( &values ) 

VALUES_print( &val, "%hhu%hd%d%qd%s", n8, n16, n32, n64, sval );

VALUES_scan( &val, "%hhu%hd%d%qd%s", &_n8, &_n16, &_n32, &_n64, &_sval );

</pre> 

h3. More on stacks

A coroutine stack consists of a continuous number of memory pages; now at the top of the stack there is a memory page that is not accessible, any attempt to read or write to this memory page will result in a SIGSEGV - acess violation signal. This turns out to be a very nice trick, when the coroutine stack grows out of proportion / overflows, then one will imedeately get to know that something got wrong.

There are times when an application will want a very large number of coroutines - in the order of tens of thousands; Now on 32 bit machine architectures one will choose a very small stack, otherwise one will run out of virtual memory to address;

Please note that with small coroutine stacks one should not allocate big arrays on the coroutine stack.

The CTHREADS package implements a pool of stacks, so that creation of coroutine will be very fast and will usually not even require even a single system call. With this purpose there is a STACKS reserves one very big continuous are of virtal memory addresses and carves the application stacks out of this memory are. The STACKS object has to be passed to coroutine thread creation function.


h3. Fibonacci example with coroutines

The same example that computes a sequence of fibonacci numbers now by using the CTHREAD coroutine package. The couroutine make_fibonacci_sequence now generates a number and calls CTHREAD_yield to switch the stack back to the caller of the couroutine, and to pass the computed value to the caller.

<pre>
#include <corothread/cthread.h>
#include <stdio.h>
#include <assert.h>
#include <math.h>

#define NUM_STACKS 10000 
#define MAX_NUM 90


// -----------------------------------------------------------------
void  make_fibonacci_sequence(VALUES *values)
{
  int i, max_num;
  void *val;
  uint64_t a,b,n;

  // retrieve argument passed to coroutine - how many iterations to run.
  VALUES_scan( values, "%d", &max_num );


  for(a = 0, b = 1, i = 0; i < max_num; i++) {
    n = a+b;
  
    // now that a new fibonacci value has been computed, it can be passed to the caller;
    // the next function switches stacks from coroutine back to the caller.  
    CTHREAD_yield( 0, "%qu", n );
    
    a=b;
    b=n;
  }

}

double sum_of_roots( size_t max_num, STACKS *stacks ) 
{
  CTHREAD *th;
  VALUES *values;
  uint64_t fib;
  int i;
  double sum_roots = 0;

  // initialise the coroutine thread
  th = CTHREAD_init( stacks, make_fibonacci_sequence );
  assert( th != 0 );

  // start coroutine. pass the value of max_num to the coroutine.
  assert( CTHREAD_start( th, &values, "%d", max_num ) == 0 );

  // on return from CTHREAD_start, the return value from the coroutine is now stored in the values object.

 	  for( i = 0 ; i < max_num && CTHREAD_state(th) != CTHREAD_STATE_EXIT; i++) {
     
     VALUES_scan( values, "%qu", &fib );

     sum_roots += sqrt( (double) fib );

     // resume the coroutine thread, switch stack to coroutine thread.  
     CTHREAD_resume( th, &values, 0 );

     // on return from CTHREAD_resume, the return value from the coroutine is now stored in the values object.

  }

  // free coroutine object.
  assert( ! CTHREAD_free( th ) );
  return sum_roots;
}


int main()
{
  STACKS stacks;
  
// library first time initialisation
  assert( !  CTHREAD_libinit() );
  
  // initialise the pool of stacks - here one stack that takes five memory pages is allocated.
  assert( !  STACKS_init( &stacks, 1 , 5 ) );

  printf("Sum of roots of fibonaci numbers: %f\n", sum_of_roots( MAX_NUM, &stacks ) );

  // release pool of stacks
  assert( ! STACKS_destroy( &stacks ) ); 

  return 0;
}
</pre>.

h3. Download instructions

Get "My stuff":https://github.com/MoserMichael/cstuff 
cd build
./build-coroutine.sh
(For platform specific stuf ./build-coroutine.sh ARCH=x86_64)
For tutorial see <root direcotory>/corothread/tutorial

h3. What comes next

The next article in this series will show how to handle IO events / non blocking sockets with coroutines; For this purpose a library will be presented that invokes a coroutine thread per new incoming connection; the couroutine will use blocking primitives in order to receive data from and write to the conection; when a connection blocks ; the library will switch the stack and handle an IO event with another coroutine.
 
