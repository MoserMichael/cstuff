---
layout: post
title:  Next project, The Pooh programming language
---

h2. {{ page.title }}
<p class="publish_date">8 November 2011</p>

I want a new tinker project, so a scripting language will be created. The project will be presented as a series of articles; the first article will define the language in some detail.

First the name; It will be the 'Pooh programming language' ; I think that if there is a Python in honor of Monty, then there should be a Pooh in honor of Pooh, so to speak, this is a long missing detail, so I will strive to correct it ;-) 

The 'Pooh programming language' will be an "Educational programming language":http://en.wikipedia.org/wiki/List_of_educational_programming_languages its purpose is to introduce kids to programming; it also will be a general purpose scripting language. 

h3. General observations on the subject of (educational) programming languages

An educational programming language should it make easy for a beginner to learn and use; that excludes statically typed languages; the learner should not spend half of his/her time fighting compilation errors. That leaves us with loosely typed scripting languages.

For me, the practice of programming mainly consists of building bridges / translations between different concepts. Very often information has to be extracted from one source (be it some textual or binary language, or GUI toolkit that receives input from a real person) also very often some existing logical formalism is used to to access structured storage (SQL comes to mind),

What I like about scripting languages is that they make it easy to create bridges between different concepts, bridges that map the concepts directly into features of the scripting language; into combinations of easy to grasp structures like hashes and dynamic arrays - those can be combined into very elaborate structures. 

An example of such a bridge between concepts is an XML parsing tool; the "Perl module XML::Simple":http://search.cpan.org/~grantm/XML-Simple-2.18/lib/XML/Simple.pm (the idea has been adapted into other scripting languages like "Ruby XML::Simple":http://xml-simple.rubyforge.org/  or "Groovy XmlSlurper":http://groovy.codehaus.org/Reading+XML+using+Groovy's+XmlSlurper  ) XML is a structured way of expression information; data in this format is magically translated into nested hashes that map tag names to the XML tree contained by that tag, XML attributes are mapped to name value pairs within the hash map that corresponds to a tag.

This way of looking at XML is a simplification of sorts, but it is much easier to work with the data this way rather than working with the "standard DOM API":http://www.w3.org/DOM/ ; 

h3. Historical justification - why is a new language needed

In the eighties computers where much simpler; the programming languages available on a home computer would be various types of Basic; Logo and Assembly for serious developers; These languages were easier to master; partly by intent of their design; partly because of the limitation of the computer platform - for example, a mini computer could not have run the whole smalltalk environment or act as a Lisp machine.

Limited computers could run only simple languages - so paradoxically the barrier of entry was lower with simple machines.

Also the limitations of the machine meant that one could do meaningful projects (by the standard of the day) with fewer means; When I was in High school, I was given a home computer as present; now it did not have any games  on it and for me it was difficult to get them; so I learned how to do my own computer games that went quite well.

What happened during later years? With the advent of Windows, schools switched to teach "basic computer literacy skills":http://en.wikipedia.org/wiki/Computer_literacy like using Word and Excel;   
Not every household had a PC, so teaching the skill of using a word processor was regarded as a significant preparation for adult life. Also programming might have lost its importants, as some societies thought that they were entering a post industrial age where financial services were more important that productive activity, but that is a digression of sorts. 

Also programming languages got more complicated; Serious langauges like C++ are notoriously hard to master; Java still is too complicated and verbose for teaching basic concepts. Scripting languages like Perl, Python and Ruby have lots of features; far too many; even Visual Basic is hard to compare with simple Basic dialects one head earlier on. 

Things lacking in old Basic dialects that where added in more powerfull scripting languages are variable scope, hashes, dynamic arrays, references, objects, regular expressions, closures. The designers of Basic probably thought that it is essential to cut all these features out, in order to have a language that is easily taught / simple to acquire; I think it is still a challenge is to create a language that combines these goodies but that still remains simple.

There are still some relatively simple languages left - Squeak; Javascript; Logo. A problem with them is that the only practical usage of these languages is from their own environment, Logo is good for moving turtles and play with words; trie to use it for something else... 

So there seems to be a place for some simple scripting language that 
makes it easy to introduce programming
is versatile enough to do real / interesting projects on real systems.

For scripting languages its is very important te be versatile; be usable in a multitude of different situations and from varying environments. As "observed here":http://dobbse.net/thinair/2006/06/play-nice.html  

bq.  ... Smalltalk's weakness is "at the boundaries:" when you want to try to do some typical unix system maintenance, or interfacing with underlying C libraries, or something similar. As long as you're staying within the Smalltalk environment, it completely rocks. But it's definitely painful if you try to reach outside. And it's especially painful if you want your code to work with different Smalltalks. What Perl got right was making it completely painless to integrate with its environment ? In some sense LISP wants to be on a LISP Machine and Smalltalk wants to be in its virtual machine, whereas Perl wants to go out and play with the other kids. The former languages are introverted and Perl is extroverted.

General purpose scripting languages have to cram in a lot of features; often design decissions are made with the aim to simplify the runtime interpreter / execution envionment, these tradeoffs tend to be counter intuitive / hard to explain; Examples of such tradeoffs made by some languages are - function variables are by default global unless declared as of local scope; values can be used before having been assigned a value; 
With an educational programming language one should strive to avoid such trade offs. 

h4. What should the final system look like

The Pooh language should come with some basic interactive environment - like a REPL where one can  edit the program and try out its parts as they are written. The environment must be friendly to bottom up software construction; one should be able to start with low level functionality, try it out and then work upword and use the simple parts to construct more complicated things.

It must be possible to integrate the environment into 'software laboratories' suited for a particular purpose. Each 'software laboratory' should integrate into a different environment; One such labority can be a tool that implements a two dimentional plane with moving sprite objects; the Pooh language would then be used to script the movement of the sprites, react to collisions or to additional input from the user ;  A different laboratory can be aimed at construction three dimensional objects scenes out of simple geometric figures; yet another 'software laboratory' can deal with grammars and parsing text with various means 

The idea is that programming language becomes embedded into multiple possible spaces; so the program would manipulate concepts from its concept space. I think that an educational programming language also requires that the developer environment for the language can be plugged into different applications. 

h3. Short summary of features to steal from other languages

And so it goes that most programming languges (especially scripting languages) are created by means of adapting / stealing features from previous programming languages.

h4. these are a few of my favorite things:

* Bash,Scheme: script debugging with _set -x_ modes ; for a small program it is easier to debug by viewing a trace of the program execution, rather than to work with a debugger.
* Perl: Strict mode - the compiler checks that a variable/function is actually defined before using it. I think that some level of syntax checking is of benefit ; misspelled identifiers should not create runtime errors - it is easier to catch these errors during compilation.
* Python: the for loop construct / generator functions used in for loops (yield statement) 
* Javascript: objects system by means of creating hash collections (prototypes)
* Lua: like the _syntax_ of the language - no major anoyances there.
* Ruby: Qualified identifiers (I don't like the choice of characters for prefix, but there should be some way of saying that an identifier refers to a class member or to a global variable) ; by default a variable in a function should be of local scope - what is done most frequently should be the shortest form; other options should be more explicit.
* Perl/Javascript/Python/Ruby/Lua: Syntax to declare a collection object and populate it with data
* Here documents: they should be similar to how "Text::Template   
Perl module":http://search.cpan.org/~mjd/Text-Template-1.45/lib/Text/Template.pm  defines template text. Should be possible to treat a string as a Here document (templates) 
* C++11: The new raw string literal (R"aaaa") that manages to work without any escape characters at all !
* Perl: The way that  "Perlfunc / Perl Functions by  Category":http://www.oopweb.com/Perl/Documents/PerlDoc/Volume/pod/perlfunc.html  documents standard library functionality in a way similar to the Roget's thesaurus.

h4. Things that I particularly dislike

* Forcing to teach object orientation right from the start, just because everything is an object. I think that teaching object orientation right from the start is confusing (not just me here ).
* Ambiguous rules; for example call-by-sharing is ambiguous (which is used in most scripting languages); Ambiguous operators that do stuff depending on he type of operands.
* C style syntax;  forced use of semicolon to finish a statement ; In particular I don't like for loop syntax that has been inherited from C. (too many functionality in one line, assignment of index, loop invariant checking and modification of loop index in one line). One could do better with foreach + generator functions.
* Python: indentation has special meaning, just can't get used to this.
* Arrays - for a beginner it is easier to have an array indexed from one onward (rather than zero); It is easier to reason about things as the first element of a sequence, etc; rather than zeroth case of prove by induction, first case of prove by induction. Basic and Lua do array indexing from one onward; Python, Perl, Javascript, C, Pascal, Algol all start with 0.
* Javascript/Perl/Lua: the var/my keywords; assigning a variable in a function results in a new global unless you have declared the local with the var keyword; I think that this is very counter intuitive to have global scope by default.
* Perl,Basic: variable prefix (suffix) for type of variable; the type of a variable should become evident from the way the variable is used.
* Perl: References and explicit dereferencing of references
* Modules and namespaces, they are necessary for building libraries, but well, could one still possibly do without them - for an introduction to programming that is ?
* Exception feature in scripting languages - I think this tool is too heavy; also most scripts (and most programs) only bail out on error and do not have to do complex error recovery sequences.
* Operator overloading in scripting languages - keeps you guessing about the meaning of an operator, does not increase readability; Javascript can do without this feature. 
* I don't like it when there are many many ways to do a string literal; but HERE documents are great
* I don't like escape sequences in string literals 
* Identifier names - in many languages identifier names consist of letters, digits and underscores. I think that this is too limiting.
* Level of detail in error messages is mostly often awful.
* All of them: Hash tables with complex keys - keys that are not strings. Ideally a hash should be able to store any object as key; well Python solves this problem by introducing "tuples":http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences  - read only sequences can be key to a hash; which results in the introduction of yet another entity. Perl does not bother with this problem - if you insert a Array as key, then it just casts its to scalar - takes the length of the array as key that is; not very intuitive either.

Entities that can be stored as keys to an array
scalars; numbers. For a string key we have to make a new copy of the string when holding it in the hash entry.
Sequences,vectors have to be copied by values, two vectors can be compare by comparing its elements; If the elements of an array are hash collections, then the hash collections have to be compared (ouch);

Is it possible to store a hash / object as key? First of all the problem is mitigated if each element of the hash collection stores the hash value of  the key; in this case the key has to be compared only in cases when the hash value of the given key is identical with a hash value of the collection entry ; in this case one must take the ordered sequence of the hash entries keys and compare the corresponding values; The hash instance could cache the ordered sequence of its keys upon demand - if the ordered sequence of keys has been computed for this instance, and the instance has not been further modified; 
Is all this worth the effort ?
In a way yes; otherwise arrays as hash keys may not hold hashes; also yet another mind bending restriction is avoided as a start;  

h4. Things that I don't know how to eat

* Regular expressions; it seems clear that a scripting language must have some form of regular expression; all was well and clear until they invented "Perl6 rules":http://en.wikipedia.org/wiki/Perl_6_rules or Perl5 " Parse::RecDescent module":http://search.cpan.org/~dconway/Parse-RecDescent-1.966_000/lib/Parse/RecDescent.pm ; now this features seems to come from "snobol   patterns":http://www.snobol4.org/docs/burks/tutorial/ch4.htm 
* Optional typing ; worth to bother if there is a JIT or compilation to native code.
* Perl: ties ; most scripting languages have some way to override certain aspects.
Perl has "ties":http://perldoc.perl.org/perltie.html ;
Lua has "metatables":http://www.lua.org/manual/5.2/manual.html#2.4  ; 
Python and Ruby have per class overrides, in python you do "__<specialname>__ methods":http://docs.python.org/reference/datamodel.html  ; 
Currently Javascript does not have any of these features, and seems to do fine without them, for what it does.


 h4. Plain problems

* Shells, Perl: Separate comparison operators for numeric and string values. Perl inherits separate string comparison operators from the UNIX shells. In Lua and Javascript one does not have them - here if a string is compared with a number, then the number is treated as a string;  Unfortunately it becomes much more difficult to infer the type of variables this way; 
* Same problem goes for arithmetic operators ; what should happen when adding a string to an number;  

h3. General Terms / General requirements.

This section spells out the general requirements for the Pooh programming language in more detail.

(GR1) Language must serve an educational purpose / be suited for the purpose of introducing kids to programming; it is a procedural language; that means that its has assignments. 
	
(GR2) Language is not classed based (no class concept with inheritance and virtual functions), instead it will have closures and objects based on "prototypes":http://en.wikipedia.org/wiki/Prototype-based_programming  - similar to JavaScript in this respect.

(GR3) The syntax may not force the user to perform anal retentive repetitive tasks over and over again ; For example it may not require the user to put in semicolon delimiter between statements - that's an  evil; or it may not require the user to declare variables / types of variables.

(GR4) The syntax must take the 'there is one way to do a thing' approach; It is not possible to do the PERL philosophy of 'there is more than one way to do a thing.

(GR5) Be fun to use. It is very difficult to quantify this or to give a definition for this concept, but we will try: 

(GR6) Encourage data driven programming / it must be possible to declare complex lists / hashes in code / Nesting of hashes and lists;

(GR7) Quickest way of debugging should be by means of a built in tracing facility. Here we learn from other languages, like in Korn/Bash shells we have set -x; in Chez Scheme there is also a very strong built in trace facility.

(GR8) Encourage bottom up software construction / exploratory programming;   (That means we need a REPL)

(GR9) Must have a wide field of application; must be able to serve as a scripting language (must not be the most efficient one for that purpose);  One should get the impression of learning something tangible.

(GR10) It must be possible to read the code - meaning that it is essential to be able to understand what a line of code does; no 'Under the scene' actions like nested construction/destruction, operator 
overloading, no macros (never), No advanced looping construct that does assign an initial value to index, check the exit condition on index and pass to next iteration in one line (like for in C); 

(GR11) There is _no_ concept of a classes with inheritance and virtual functions.  Normal people (not conditioned by years of programming practice) are no good at growing / maintaining hierarchies, the class concepts is very confusing on first use (usually there is a multitude of possible ways to decompose a system into classes). 
Further justification: usually people try to avoid hierarchies in their daily life, they always try.
Examples
     People tend to put all their file on the desktop instead of creating hierarchies of folders.
     Discussion boards: Once upon a time each discussion board had threaded discussions (each item had its replies, etc. Nowadays Facebook doesn't have that; it's simpler to manage for most people; I think Joel on Software said that first with regards to discussion boards. Once upon a time that was really a very novel view on things.

 Instead of classes there will be closures and "prototype classes":http://en.wikipedia.org/wiki/Prototype-based_programming; closures are a 'poor mans classes'; also SICP doesn't do classes and is regarded as a good intro to programming languages (alas for people who are already programmers). In a way, closures are not  too intuitive either; but we will try;

(GR12) Error message must be very detailed and helpful. 

(GR13) Ideally there will be two ways of evaluating the program; one as a very basic interpreter that evaluates the program by walking the abstract syntax tree, the other is by creating an executable file (will use LLVM compiler backend). 

(GR14) An object in a scripting language is equivalent to a hash map, the layout of an object can therefore be changed at will; In a compiled language the layout of a class must be fixed. The pooh scripting language will walk the middle ground, there will be a way to construct a hash map by means of a declaration, so that one cannot insert or remove elements from that hash map after its construction;  or for an existing key insert a value of a different type. Such an object can be efficiently translated to machine language, as its layout / type will be known throughout runtime. 
(????) 

h3. Defining the Pooh language in more detail

(R1) Language must be _somewhat_ dynamically typed; A variable is defined by assigning a value to a name; if identifier on the left hand side is not defined, it is hereby defined as a local variable in the current scrope. If the assignment is in a function, and variable is not yet defined, then the variable scope is in the function; if the assignment is a global scope, then the variable will be a global variable.
 
(R2) Variable binding is created either by assignment or by parameter declaration;  One does not need to declare a variable.

(R3) One may not reference a variable that is not defined - this will be an error. (like STRICT mode in Perl - this will be the only available option). 

(R4) Variable names; There variable may have the following form
* in Perl and Basic, the varialble prefix, suffix encodes the type of the variable; In Fortran the name ofthe variable implies its type. 
* In Ruby, the prefix encodes the scope of a variable.
* Other languages do not encode type of scope information as part of the variable name.

The problem remains that 

(R4) Variable scope: A variable first assigned at global scope is global, a name assigned in a function is of local scope; 

* Variable scope; there are several possible ways / dilemmas.
 
_Unqualified identifiers_ a name is first interpreted as function local; if there is no such variable then enclosing functions scope is tested for that name; if there is one, then we have a new closure, otherwise global scope is tested for that name; if a global variable is found then we have a reference to it. See also   http://en.wikipedia.org/wiki/Scope_(computer_science)#Qualified_identifiers :here

There are several problems with this approach:
Problem: One also has declare a variable somehow before using it, as one needs to know if this is a local or a global or whatever scope, without this there is too much ambiguity regarding the source of a variable (like in python);

For example in javascript one has to define a local with var keyword, otherwise it is a global, or in Perl one has my keywords.to say that a variable is a  local

Problem: it is not clear what a variable reference means by looking at its use;  
Problem: One may take the nearest scope rule, that is a variable is local is has a local binding and has no global binding like in Python. Now by adding a global with the same name as a local variable you will now have a global instead of a local. Not nice.

_Qualified identifiers_  the  syntax has some means to tell if this name is supposed to be interpreted as function local/enclosing function scope or global scope; if not qualifier is given then current scope is meant; 

For example in Ruby one has the $ prefix to tell that a variable is used as a global and @ prefix to tell that a variable is used as a object member. Or in Javascript one says this.variablename that tells if one means to access a class member.

I think that Qualified identifiers are better for code readability, one knows the context of a variable usage by looking at it;  also it avoids the need to declare variables before assignment.
Qualified identifiers may be a very verbose way of expressing variable usage, but well, I it makes you more aware of what you are doing, which can be of benefit; 

So for the Pooh language we will have 
	_this . _ variablename  - if variablename is a class member
	_global . _variablename  - if variablename is a global
	_close . _ variablename - if  variablename is to capture the value of an enclosing block.
	variablename - if variablename is a local variable when used in a function; at global scope this will be a global reference. This is also the most common usage, so it has the shortest form of writing.  

 
(R5) A value may have one of the following types
scalar, with numeric value type
scalar, with string value type
scalar, with lambda value (reference to function)
dynamic array
hash

(R6) Operators should strictly have one meaning; I don't like operators where the meaning depends on the type operand types.

* There are numeric comparison operators: <>  , == ,  > , <  , >= , <= ; 
Numeric operators  + , - , * , / , %
For these operators the operands must be of numeric type; the operand may not be a hash, dynamic array or function type.

* There are string comparison operators:  ne , eq , gt , lt , le , ge - here both operands must be string values.

* String concatenation operator ..
For these concatenation operator, the operands may be either of numeric type or of string type; a numeric value will be turned to string value implicitly. 
	
(R7) do not have to define the type of a variable; it will become obvious from how the variable is later used; if a variable is used as an array (a[ 0 ] = 0 ), then a is  an array; the same variable name can not be later used as if it were a scalar. Problem: it is not always possible to tell the type of a binding: If you insert something into an array / hash, then later access to this entry is untyped and must be checked at 
run time;

General principle: If you can infer the type of something during parsing/compilation then do so, if you can't then defer type check to run time ('somewhat' dynamically typed)

(R8) Semantics of values; The choices are

* Everything is a reference; after assignment the left hand side points to the same data as the right hand side.
* There are primitive types and object references (Java, Scala); In case that right hand side is a primitive type then assignment copies the value; if the right hand side is a reference, then the reference is copied by value and the left hand side then points to the same thing.
* There are primitive types, object references and object instances (C,C++). Assignment copies the value of primitive types and 

What is the most appropriate thing to do here?

Everything is a reference - it assumes that numbers are objects like everything else; This approach is not commonly used.  Also you have this very convenient analogy of assignment and equations of simple Algebra, which gets lost if you treat everything like a reference

Scalars (strings and numbers) are always treated as values; Arrays and hashes are treated as references; Here the problem is that the assignment operator can eithe mean copying by value - for scalars, and copy by reference - for collections; The same assignment operator means different things, depending on the context - which is bad.

Values and references:  a variable may be bound to the instance of a data item, or be a reference to a value. This is very flexible, but this is also a very complex concept. Here one would need a way to create a reference (\) and a way to dereference a reference - very powerful and very confusing concept.   

I would propose a different appraoch - 
a = b. Assignment always means 'copy by value' ; for scalars a new copy is created. Copying collection (array, hashes) creates a new collection instance, now each element of the array is copied too -  if an array element is a value, a new copy is created, if the array element is a referece, then the new element will refer to the same data item.

a := b - here the left hand side (variable a) would become a reference to the right hande side ( variable b ) ; if he right hand side is a reference, then the reference is copied - the left hand side will refer to the same object as the right hand side.

No operator exists for dereferencing of a reference - reference and values are used in the same way.

Why should this be simpler then having a reference and dereference operator ? First there are no references to reference, Also there is no operator to dereference a reference, 

(R9) Functions have prototypes; One function can have one prototype (no overloading); The prototype defines the names of the parameters, type of parameters is derived/infered from usage of parameter.

(R10) Parameter passing / Evaluation strategy.
 
Possible choices
1.all call by value
2.all call by reference
3.Collections are passed as reference to collection; scalars as call by value (call by sharing)

Many programming languages (Lisp,Lua, Python, Java) do choice (3);  which is very confusing by its ambiguity, different rules apply for scalars and for collections.

Call by reference is not very practical; If everything is a referene then each parameter can be a return value; so by looking at a function call you can't tell what it will change or not; by allowing call by reference you will have too many possible side effects.

So Call by value (1) is the least worst choice; alas if a reference is passed, then it is passed as is. On another note this decission forces the language implementations to do reference counted strings (or copy on write strings) - otherwise a new string copy would be created whenever a string parameters is passed as argument to a function; . 

(R11) Check function prototype on call: If function is called directly then check number of parameters and if their types match (for example check if scalar is not passed instead of an array); If type is difficult to establish (function reference stored in hash) then defer check to run time; the type of a parameter is determined by how it is used (very simplistic form of type inference)
  	
(R12) functions are 'first class' - meaning that we have anonymous functions, and 
functions can be returned as return values, etc. 

(R13) The Haskell programming language has a nice feature that if-then-else statement always requires an else clause - this forces the programmer to consider the what else scenario; however this nice feature contradicts with requirement of non-anal-retentiveness; so it is not accepted.

(R14) Reflection, will be done as a library, so no need for special syntactic constructs here.

(R12) Co-routines / will have generator functions with yield; *must have for nice iteration *;

(R13)  Things to cut: exceptions, namespaces, classes (also cuts Generic types, so the innovation of doing without classes :really makes things much more feasible); no macros / no meta programming at all; No blocks as function closures (this feature might add to more concise code, but is very confusing - is it a statement? Is it a function? ) ; no syntax that does many things at once - like for statements in C; 

(R15)  Also one needs array slices in order to return multiple variables from functions.

(R16) String literals; there are many possible choices "article on string literals ":http://en.wikipedia.org/wiki/String_literal explains the many notations for a string literal  "here documents - multiple line strings":http://en.wikipedia.org/wiki/Here_document explains more about strings that span multiple lines; Perl achieves a great degree of expressiveness at the cost of introducing multiple kinds of string literals. I guess it is a bit complicated to memorize so many notations, especially if one is new to programming. 
 
There are therefore the following requirements for  a string notation. 
* it should not have any escape sequences
* it must express multiple line strings, sort of like "Here documents"
* must allow for embedding of code into the string; the result of evaluating the code will be inserted into the string.

Escape sequences can be avoided, if the definition of  the HERE document contains a definition of the end of string delimiter; 

<notextile>
R#aaa bbb ccc #
<p>
</notextile>  

this construct is similar to HERE document; It says that anything between the two # characters is part of the string. Alterternatively one can have delimiters of multiple characters; The delimiter string may not start wiht (Ouch).

<notextile>
R#%aaa bbb ccc #%
<p>
</notextile>  

Anything between the two #% delimiters is part of the string.

Now it is also possible to include expressions as part of the string - these expressions are evaluated and their result is inserted into the string.
<notextile>
@" aa #{ a + b } cc "
</notextile>

Here the string #{ a + b } is not part of the string; it contains the expression a + b,  this expression will be evaluated and the result is inserted into the string. 
By default delimiter #{ means start of embedded code section; } will close this code section. The delimiter #{ not create too many clashes, so this seems to be a good default value. 

Now the question is how to customize the start, end of embedded code markers; it could be done as follows

<notextile>
R([[ ]])"aaa [[ a + b ]] ccc" 
</notextile>

If R starts with a ( character then the form reads as :
R( <start of embedded code marker> <end of embedded code marker>)<string delimitor> string content <string delimitor>

This is a powerful construct, so it is therefore a bit complicated; however I think that on a global level it is less complex to have one string literal notation with variations, instead of five different string notations like in Perl (maybe there are more of them, I counted five of them though).  

(R17) There are function prototypes, therefore have to decide what to do with the problem of function overloading; - can there be two different functions with the same name that take a different set of arguments ?
 
I think function overloading can be skipped due to the simplicity requirement.  
Also scripting languages or loosely typed programming languages in general do not have this feature / even Rub y doesn't have it.



       
