---
layout: post
title:  Next project, The Pooh programming language
---

h2. {{ page.title }}
<p class="publish_date">8 November 2011</p>

I want a new tinker project, so a scripting language will be created. The project will be presented as a series of articles; the first article will define the language in some detail.

First the name; It will be the 'Pooh programming language' ; I think that if there is a Python in honor of Monty, then there should be a Pooh in honor of Pooh, so to speak, this is a long missing detail, so I will strive to correct it ;-) 

The 'Pooh programming language' will be an "Educational programming language":http://en.wikipedia.org/wiki/List_of_educational_programming_languages its purpose is to introduce kids to programming; it also will be a general purpose scripting language. 

h3. General observations on the subject of (educational) programming languages

An educational programming language should it make easy for a beginner to learn and use; that excludes statically typed languages; the learner should not spend half of his/her time fighting compilation errors. That leaves us with loosely typed scripting languages.

For me, the practice of programming mainly consists of building bridges / translations between different concepts. Very often information has to be extracted from one source (be it some textual or binary language, or GUI toolkit that receives input from a real person) also very often some existing logical formalism is used to to access structured storage (SQL comes to mind),

What I like about scripting languages is that they make it easy to create bridges between different concepts, bridges that map the concepts directly into features of the scripting language; into combinations of easy to grasp structures like hashes and dynamic arrays - those can be combined into very elaborate structures. 

An example of such a bridge between concepts is an XML parsing tool; the "Perl module XML::Simple":http://search.cpan.org/~grantm/XML-Simple-2.18/lib/XML/Simple.pm (the idea has been adapted into other scripting languages like "Ruby XML::Simple":http://xml-simple.rubyforge.org/  or "Groovy XmlSlurper":http://groovy.codehaus.org/Reading+XML+using+Groovy's+XmlSlurper  ) XML is a structured way of expression information; data in this format is magically translated into nested hashes that map tag names to the XML tree contained by that tag, XML attributes are mapped to name value pairs within the hash map that corresponds to a tag.

This way of looking at XML is a simplification of sorts, but it is much easier to work with the data this way rather than working with the "standard DOM API":http://www.w3.org/DOM/ ; 

h3. Justification - why is a new language needed

In the eighties computers where much simpler; the programming languages available on a home computer would be various types of Basic; Logo and Assembly for serious developers; These languages were easier to master; partly by intent of their design; partly because of the limitation of the computer platform - for example, a mini computer could not have run the whole smalltalk environment or act as a Lisp machine.

Limited computers could run only simple languages - so paradoxically the barrier of entry was lower with simple machines.

Also the limitations of the machine meant that one could do meaningful projects (by the standard of the day) with fewer means; When I was in High school, I got a home computer as present; now it did not have any games  on it and for me it was difficult to get them; so I learned how to do my own computer games that went quite well.

What happened during later years? With the advent of Windows, schools switched to teach "basic computer literacy skills":http://en.wikipedia.org/wiki/Computer_literacy like using Word and Excel;   
Not every household had a PC, so teaching the skill of using a word processor was regarded as a significant preparation for adult life. Also programming might have lost its importants, as some societies thought that they were entering a post industrial age where financial services were more important that productive activity, but that is a digression of sorts. 

Also programming languages got more complicated; Serious langauges like C++ are notoriously hard to master; Java still is too complicated and verbose for teaching basic concepts. Scripting languages like Perl, Python and Ruby have lots of features; far too many; even Visual Basic is hard to compare with simple Basic dialects one head earlier on.

There are still some relatively simple languages left - Squeak; Javascript; Logo. A problem with them is that the only practical usage of these languages is from their own environment, Logo is good for moving turtles and play with word; trie to use it for something else... 

For scripting languages its is very important te be versatile; be usable in a multitude of different situations and from varying environments. As "observed here":http://dobbse.net/thinair/2006/06/play-nice.html  

<pre>
..  Smalltalk's weakness is "at the boundaries:" when you want to try to do some typical unix system maintenance, or interfacing with underlying C libraries, or something similar. As long as you're staying within the Smalltalk environment, it completely rocks. But it's definitely painful if you try to reach outside. And it's especially painful if you want your code to work with different Smalltalks. What Perl got right was making it completely painless to integrate with its environment.

In some sense LISP wants to be on a LISP Machine and Smalltalk wants to be in its virtual machine, whereas Perl wants to go out and play with the other kids. The former languages are introverted and Perl is extroverted.
</pre>

h4. The right way to do it



The Pooh language should come with some basic interactive environment - like a REPL where one can  edit the program and try out its parts as they are written. The environment must be friendly to bottom up software construction; one should be able to start with low level functionality, try it out and then work upword and use the simple parts to construct more complicated things.

It must be possible to integrate the environment into 'software laboratories' suited for a particular purpose. Each 'software laboratory' should integrate into a different environment; One such labority can be a tool that implements a two dimentional plane with moving sprite objects; the Pooh language would then be used to script the movement of the sprites, react to collisions or to additional input from the user ;  A different laboratory can be aimed at construction three dimensional objects scenes out of simple geometric figures; yet another 'software laboratory' can deal with grammars and parsing text with various means 

The idea is that programming language becomes embedded into multiple possible spaces; so the program would manipulate concepts from its concept space. I think that an educational programming language also requires that the developer environment for the language can be plugged into different applications. 

h3. Short summary of features to steal from other languages

And so it goes that most programming languges (especially scripting languages) are created by means of adapting / stealing features from previous programming languages.

h4. these are a few of my favorite things:

* Bash,Scheme: script debugging with _set -x_ modes ; tracing instead of debugging.
* Perl: Strict mode - the compiler checks that a variable/function is actually defined before using it.
* Python: the for loop construct / generator functions used in for loops (yield statement) 
* Javascript: objects system by means of cloning hashes (prototypes)
* Lua: like the _syntax_ of the language - no major anoyances there.
* Ruby: Qualified identifiers (I don't like the choice of characters for prefix, but there should be some way of saying that an identifier refers to a class member or to a global variable) ; by default a variable in a function should be of local scope - what is done most frequently should be the shortest form; other options should be more explicit.
* Perl/Javascript/Python/Ruby/Lua: Syntax to declare a collection object and populate it with data
* Here documents: they should be similar to how "Text::Template   
Perl module":http://search.cpan.org/~mjd/Text-Template-1.45/lib/Text/Template.pm  defines template text. Should be possible to treat a string as a Here document (templates) 
* C++11: The new raw string literal (R"aaaa") that manages to work without any escape characters at all !
* Perl: The way that  "Perlfunc / Perl Functions by
* Category":http://www.oopweb.com/Perl/Documents/PerlDoc/Volume/pod/perlfunc.html  documents standard library functionality in a way similar to the Roget's thesaurus.

    
 
h4. Things that I particularly dislike

* C style syntax;  forced use of semicolon to finish a statement ; In particular For I don't like for loop syntax that has been inherited from C. (too many functionality in one line, assignment of index, loop invariant checking and modification of loop index in one line). One could do better with foreach + generator functions.
* Python: Spaces in syntax, just can't get used to them.
* Javascript/Perl/Lua: the var/my keywords; assigning a variable in a function results in a new global unless you have declared the local with the var keyword; I think that this is very counter intuitive.
* Perl: variable prefix for type of variable; the type of a variable should become evident from using it.
* Perl: References and explicit dereferencing of references
* Modules and namespaces, they are necessary for building libraries, but well, could one still possibly do without them ?
* Exception feature in scripting languages - I think the tool is too heavy for a script.
* Operator overloading in scripting languages.
* I don't like escape sequences in string literals
* I don't like it when there are many many ways to do a string literal; but HERE documents are great
* Level of detail in error messages is mostly often awful. 
* All of them: Hash tables with complex keys - keys that are not strings.
Python solves this problem by introducing "tuples":http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences  - read only sequences can be key to a hash; Yet another entity ?.
		
	       In Perl you can have arrays as hash keys, but if you modify the key array then it will no longer be found.
 
	       The best solution (for the user) would be to turn the key structure into Read-only mode; say you have an array or hash object that acts as a hash key; once this object has been used as a hash key it will turn into a 'read only object' that cannot be modified.
 

h4. Things that I don't know how to eat\
* Regular expressions; it seems clear that a scripting language must have some form of regular expression; all was well and clear until they invented "Perl6 rules":http://en.wikipedia.org/wiki/Perl_6_rules or Perl5 " Parse::RecDescent module":http://search.cpan.org/~dconway/Parse-RecDescent-1.966_000/lib/Parse/RecDescent.pm ; now this features seems to come from "snobol   patterns":http://www.snobol4.org/docs/burks/tutorial/ch4.htm 
* Optional typing ; worth to bother if there is a JIT or compilation to native code.
* Perl: ties ; most scripting languages have some way to override certain aspects.
Perl has "ties":ties":http://perldoc.perl.org/perltie.html ;
Lua has "metatables":http://www.lua.org/manual/5.2/manual.html#2.4  ; 
Python and Ruby have per class overrides, in python you do "__<specialname>__ methods":http://docs.python.org/reference/datamodel.html  ; 
Currently Javascript does not have any of these features, and seems to do fine without them, for what it does.


 


h3. General Terms / General requirements.

This section spells out the general requirements for the Pooh programming language in more detail.

(GR1) Language must serve an educational purpose / be suited for the purpose of introducing kids to programming; it is a procedural language; that means that its has assignments. 
	
(GR2) Language is not classed based (no class concept with inheritance and virtual functions), instead it will have closures and objects based on "prototypes":http://en.wikipedia.org/wiki/Prototype-based_programming  - similar to JavaScript in this respect.

(GR3) The syntax may not force the user to perform anal retentive repetitive tasks over and over again ; For example it may not require the user to put in semicolon delimiter between statements - that's an  evil; or it may not require the user to declare variables / types of variables.

(GR4) The syntax must take the 'there is one way to do a thing' approach; It is not possible to do the PERL philosophy of 'there is more than one way to do a thing.

(GR5) Be fun to use. It is very difficult to quantify this or to give a definition for this concept, but we will try: 

(GR6) Encourage data driven programming / it must be possible to declare complex lists / hashes in code / Nesting of hashes and lists;

(GR7) Quickest way of debugging should be by means of a built in tracing facility. Here we learn from other languages, like in Korn/Bash shells we have set -x; in Chez Scheme there is also a very strong built in trace facility.

(GR8) Encourage bottom up software construction / exploratory programming;   (That means we need a REPL)

(GR9) Must have a wide field of application; must be able to serve as a scripting language (must not be the most efficient one for that purpose);  One should get the impression of learning something tangible.

(GR10) It must be possible to read the code - meaning that it is essential to be able to understand what a line of code does; no 'Under the scene' actions like nested construction/destruction, operator 
overloading, no macros (never), No advanced looping construct that does assign an initial value to index, check the exit condition on index and pass to next iteration in one line (like for in C); 

(GR11) There is _no_ concept of a classes with inheritance and virtual functions.  Normal people (not conditioned by years of programming practice) are no good at growing / maintaining hierarchies, the class concepts is very confusing on first use (usually there is a multitude of possible ways to decompose a system into classes). 
Further justification: usually people try to avoid hierarchies in their daily life, they always try.
Examples
     People tend to put all their file on the desktop instead of creating hierarchies of folders.
     Discussion boards: Once upon a time each discussion board had threaded discussions (each item had its replies, etc. Nowadays Facebook doesn't have that; it's simpler to manage for most people; I think Joel on Software said that first with regards to discussion boards. Once upon a time that was really a very novel view on things.

 Instead of classes there will be closures and "prototype classes":http://en.wikipedia.org/wiki/Prototype-based_programming; closures are a 'poor mans classes'; also SICP doesn't do classes and is regarded as a good intro to programming languages (alas for people who are already programmers). In a way, closures are not  too intuitive either; but we will try;

(GR12) Error message must be very detailed and helpful. 

(GR13) Ideally there will be two ways of evaluating the program; one as a very basic interpreter that evaluates the program by walking the abstract syntax tree, the other is by creating an executable file (will use LLVM compiler backend). 

(GR14) An object in a scripting language is equivalent to a hash map, the layout of an object can therefore be changed at will; In a compiled language the layout of a class must be fixed. The pooh scripting language will walk the middle ground, there will be a way to construct a hash map by means of a declaration, so that one cannot insert or remove elements from that hash map after its construction;  or for an existing key insert a value of a different type. Such an object can be efficiently translated to machine language, as its layout / type will be known throughout runtime. 
(????) 

h3. Defining the Pooh language in more detail

(R1) Language must be _somewhat_ dynamically typed; A variable is defined by assigning a value to a name; if identifier on the left hand side is not defined, it is hereby defined as a local variable in the current scrope. If the assignment is in a function, and variable is not yet defined, then the variable scope is in the function; if the assignment is a global scope, then the variable will be a global variable.
 
(R2) Variable binding is created either by assignment or by parameter declaration;  One does not need to define a variable by special syntax.

(R3) One may not reference a variable that is not defined - this will be an error. (like STRICT mode in Perl - this will be the only available option). 

(R4) Variable scope: A variable first assigned at global scope is global, a name assigned in a function is of local scope; 

* Variable scope; there are several possible ways / dilemmas.
 
_Unqualified identifiers_ a name is first interpreted as function local; if there is no such variable then enclosing functions scope is tested for that name; if there is one, then we have a new closure, otherwise global scope is tested for that name; if a global variable is found then we have a reference to it. See also   http://en.wikipedia.org/wiki/Scope_(computer_science)#Qualified_identifiers :here

There are several problems with this approach:
Problem: One also has declare a variable somehow before using it, as one needs to know if this is a local or a global or whatever scope, without this there is too much ambiguity regarding the source of a variable (like in python);

For example in javascript one has to define a local with var keyword, otherwise it is a global, or in Perl one has my keywords.to say that a variable is a  local

Problem: it is not clear what a variable reference means by looking at its use;  
Problem: One may take the nearest scope rule, that is a variable is local is has a local binding and has no global binding like in Python. Now by adding a global with the same name as a local variable you will now have a global instead of a local. Not nice.

_Qualified identifiers_  the  syntax has some means to tell if this name is supposed to be interpreted as function local/enclosing function scope or global scope; if not qualifier is given then current scope is meant; 

For example in Ruby one has the $ prefix to tell that a variable is used as a global and @ prefix to tell that a variable is used as a object member. Or in Javascript one says this.variablename that tells if one means to access a class member.

I think that Qualified identifiers are better for code readability, one knows the context of a variable usage by looking at it;  also it avoids the need to declare variables befor assignment.
Qualified identifiers may be a very verbose way of expressing variable usage, but well, I it makes you more aware of what you are doing, which can be of benefit; 

So for the Pooh language we will have 
	_this . _ variablename  - if variablename is a class member
	_global . _variablename  - if variablename is a global
	_close . _ variablename - if  variablename is to capture the value of an enclosing block.
	variablename - if variablename is a local variable when used in a function; at global scope this will be a global reference. This is also the most common usage, so it has the shortest form of writing.  

 
(R10) A value may have one of the following types
scalar, with numeric value type
scalar, with string value type
scalar, with lambda (reference to function)
dynamic array
hash

* Operators must either enforce the type of the arguments or it must convert types explicitly; for example the expression <string> + <integer> either disallows such a combination; or it performs implicit conversion of <integer> to <string> and is interpreted as string concatenation; or it tries to interpret <string> as an <integer>; I think the implicit conversion business is too wishy-washy. An operator is supposed to have a meaning, that is now subject to some strange interpretation. So here we stick with Perl like convention;

* There are numeric comparison operators: <>  , == ,  > , <  , >= , <= ; 
Numeric operators  + , - , * , / , %
For these operators the operands must be of numeric type; the operand may not be a hash, dynamic array or function type.

* There are string comparison operators:  .. ne , eq , gt , lt , le , ge
Special string concatenation operator ..
For these operators the operands may be either of numeric type or of string type; a numeric value will be turned to string value implicitly. 
	
(R6) do not have to define the type of a variable; it will become obvious from how the variable is later used; if a variable is used as an array (a[ 0 ] = 0 ), then a is  an array; the same variable name can not be later used as if it were a scalar. Problem: it is not always possible to tell the type of a binding: If you insert something into an array / hash, then later access to this entry is untyped and must be checked at 
run time;

General principle: If you can infer the type of something during parsing/compilation then do so, if you can't then defer type check to run time ('somewhat' dynamically typed)

(R6) Meaning of assignment

Everything is a reference; after assignment the left hand side points to the same data as the right hand side.
There are primitive types and object references (Java, Scala); In case that right hand side is a primitive type then assignment copies the value; if the right hand side is a reference, then the reference is copied by value and the left hand side then points to the same thing.
There are primitive types, object references and object instances (C,C++). Assignment copies the value of primitive types and 

What is the most appropriate thing to do here?

Everything is a reference - it assumes that numbers are objects like everything else; 
Also with Basic you have this very convenient analogy of expressions to simple Algebra, which gets lost if you treat everything like a reference

Primitive types and references: The problem here is that assignment of numbers is a special case; either the number object has to be cloned explicitly (choice A), or the cloning of number object is done 'under the hood' (choice B); or you have a different operator for copying an object by value and by reference a = 12 / b = [ 1, 2, 4 ] would be copy by value  (deep copy, if the array contains other arrays and hashes, then these will be copied too); and  a <= 10 / b <= [ 1, 2, 3 ] . I think that this is a clearer approach. There is no operator to dereference a reference;   

(R7) Functions have prototypes; One function can have one prototype (no overloading); The prototype defines the names of the parameters, type of parameters is derived/infered from usage of parameter.

(R7) Parameter passing:
 
Possible choices
1.all call by value
2.all call by reference
3.Collections are passed as reference to collection; scalars as call by value;
Regular programming languages do choice (3); choice (2) is slow and impractical. Why not (1) ? I guess that if everything is a referene then each parameter can be a return value; so by looking at a function call you can't tell what it will change or not; by allowing call by reference you will have too many possible side effects.
So (3) is the least worst choice. 

(R8) Check function prototype on call: If function is called directly then check number of parameters and if their types match (for example check if scalar is not passed instead of an array); If type is difficult to establish (function reference stored in hash) then defer check to run time; the type of a parameter is determined by how it is used (very simplistic form of type inference)
  	
(R9) functions are 'first class' - meaning that we have anonymous functions, and 
functions can be returned as return values, etc. 

(R10) The Haskell programming language has a nice feature that if-then-else statement always requires an else clause - this forces the programmer to consider the what else scenario; however this nice feature contradicts with requirement of non-anal-retentiveness; so it is not accepted.

(R11) Reflection, will be done as a library, so no need for special syntactic constructs here.

(R12) Co-routines / will have generator functions with yield; *must have for nice iteration *;

(R13)  Things to cut: exceptions, namespaces, classes (also cuts Generic types, so the innovation of doing without classes :really makes things much more feasible); no macros / no meta programming at all; No blocks as function closures (this feature might add to more concise code, but is very confusing - is it a statement? Is it a function? ) ; no syntax that does many things at once - like for statements in C; 

(R14) To be handy we have a built in regular expressions

(R15)  Also one needs array slices in order to return multiple variables from functions.

(R16) String literals; there are many possible choices "article on string literals ":http://en.wikipedia.org/wiki/String_literal explains the many notations for a string literal  "here documents - multiple line strings":http://en.wikipedia.org/wiki/Here_document explains more about strings that span multiple lines; Perl achieves a great degree of expressiveness at the cost of introducing multiple kinds of string literals. I guess it is a bit complicated to memorize so many notations, especially if one is new to programming. 
 
There are therefore the following requirements for  a string notation. 
* it should not have any escape sequences
* it must express multiple line strings, sort of like "Here documents"
* must allow for embedding of code into the string; the result of evaluating the code will be inserted into the string.

Escape sequences can be avoided, if the definition of  the HERE document contains a definition of the end of string delimiter; 

<notextile>
R#aaa bbb ccc #
<p>
</notextile>  

this construct is similar to HERE document; It says that anything between the two # characters is part of the string. Alterternatively one can have delimiters of multiple characters; The delimiter string may not start wiht (Ouch).

<notextile>
R#%aaa bbb ccc #%
<p>
</notextile>  

Anything between the two #% delimiters is part of the string.

Now it is also possible to include expressions as part of the string - these expressions are evaluated and their result is inserted into the string.
<notextile>
@" aa #{ a + b } cc "
</notextile>

Here the string #{ a + b } is not part of the string; it contains the expression a + b,  this expression will be evaluated and the result is inserted into the string. 
By default delimiter #{ means start of embedded code section; } will close this code section. The delimiter #{ not create too many clashes, so this seems to be a good default value. 

Now the question is how to customize the start, end of embedded code markers; it could be done as follows

<notextile>
R([[ ]])"aaa [[ a + b ]] ccc" 
</notextile>

If R starts with a ( character then the form reads as :
R( <start of embedded code marker> <end of embedded code marker>)<string delimitor> string content <string delimitor>

This is a powerful construct, so it is therefore a bit complicated; however I think that on a global level it is less complex to have one string literal notation with variations, instead of five different string notations like in Perl (maybe there are more of them, I counted five of them though).  

(R17) There are function prototypes, therefore have to decide what to do with the problem of function overloading; - can there be two different functions with the same name that take a different set of arguments ?
 
I think function overloading can be skipped due to the simplicity requirement.  
Also scripting languages or loosely typed programming languages in general do not have this feature / even Ruby doesn't have it.



       
