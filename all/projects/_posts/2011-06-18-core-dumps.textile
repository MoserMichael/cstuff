---
layout: post
title: Making sense of a core dump that occurred at remote location
---

h2. {{ page.title }}
<p class="publish_date">18 July 2011</p>

One thing that happens to C/C++ programs is that they crash at customer sites, usually a "Core dump":http://en.wikipedia.org/wiki/Core_dump  is left after the crash .

Now it happens that core dump is sent to you from a remote customer site, and joy and wonder, you can't get a meaningful stack trace out of it. (Usually that is the point to start loud chanting of the "Segmentation violation - Core dumped blues":http://www.netfunny.com/rhf/jokes/92q3/coredb.html

Now	
- One reason may be that the "stack is smashed":http://en.wikipedia.org/wiki/Stack_buffer_overflow in this case you can't get any information, sorry. (well we "have a solution right here":/cstuff/all/projects/2011/06/19/stack-mirror.html  , but that's a different story ...)

- Another reason is that you have compiled the program with Optimization and frame pointer omission enabled, in this case you won't see any information either. Don't do that ( add -fno-frame-pointer-omission) . Well actually "Yossi Kreinin" http://www.yosefk.com/", with a "very clever trick":http://www.yosefk.com/blog/getting-the-call-stack-without-a-frame-pointer.html

- The third one (very likely) is that the crash occurs in a shared library (libc,pthread, oracle client, etc), and it can't be traced, because your system has a slightly different versions of this shared library as compared to what you have locally on your machine. Now this situation can be solved, so now it's scripting time (Perl to the rescue)

- Another scenario is when a system / third party shared library calls you back, In this case you are bound to see a different stack on your machine, of third party library is different from what you have. An example is C++ stack unwinding; when an exception is caught, then GLIBC is calling your code, it is calling object destructors of stack based objects.

The script does the following:

- Get path of all dependent shared libraries (parse result of ldd <executable> )
- Copy shared libraries , the core file, the binary file and make an archive out of this
- Create a shell script that instructs GDB to use the copied shared libraries instead of what you got on your system. (here goes the trick)

Now "here is the script":https://github.com/MoserMichael/cstuff/blob/master/scripts/gather-libs.pl  that does it all.
.h3 how to use it

<pre>
./gather-libs.pl -c core.12345 -e exe_file -o out.tbz2
</pre>
Creates the archive out.tbz2 that includes 
- Core file core.12345
- Executable exe_file and all its dependent shared libraries
- The script run.sh that invokes gdb with the copied shared libraries
Now once you have copied archive out.tbz2 over to your machine you can open it

<pre>
tar xvfj out.bz2
</pre>

Now script run.sh will first check if the executable has any debug information; if it does the gdb is run with copied shared libraries.
To run with a different core file

<pre>
./run.sh -c core.2345
</pre>

To run with a different executable and core

<pre>
,/run.sh -c core.2345 -e another-exe:
</pre>

h3. How to tell gdb to look at different set of share libraries.

Gdb has the following command 

bq. set solib-absolute-path  <path>

It tells gdb to look for shared libraries from under <path>. Now the archive contains script run.sh ; which writes the following gdb script to a temporary file

<pre>
set solib-absolute-prefix .
core-file <core file name>
</pre>

Then it starts gdb with this generated script (-x option of gdb). 
Now doing a script that writes another script is an exercise in magic (small magic alas). 


