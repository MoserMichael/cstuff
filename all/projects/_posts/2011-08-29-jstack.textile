---
layout: post
title:  jstack - the missing manual / debugging java programs
---

h2. {{ page.title }}
<p class="publish_date">29 August 2011</p>


The "jstack":http://linux.die.net/man/1/jstack-java-1.6.0-openjdk  utility is part of "Hotspot JVM":http://en.wikipedia.org/wiki/HotSpot, it is a command line program that obtains the current stack trace of all java threads. Actually it is one of the strong points of java that you can always get a stack trace for all threads of a process / list of all locks. With 'unmanaged' c programs it is not quite so easy, not at all.

So when you are running jstack on Linux (or any other Unix) then there are some details that are missing from the documentations 

- The jstack utility and JVM have to be from the same version of the JDK. If you have several versions of java installed then go figure.
- The jstack utility and traced java process should run under the same user account. This needs some explanation

Let us trace the system calls for running jstack on process id 10015

<pre>
strace -f  -oo /usr/java/jdk1.6.0/bin/jstack  -l  10015

grep -F 'connect(' o

11558 connect(6, {sa_family=AF_FILE, path="/tmp/.java_pid10015"}, 110) = 0
11558 connect(6, {sa_family=AF_FILE, path="/tmp/.java_pid10015"}, 110) = 0
</pre>

Interestingly jstack uses a "named pipe":http://en.wikipedia.org/wiki/Named_pipe with the file name of  /tmp/.java_pid<processed>  in order to communicate with the JVM of the traced process.  Communication via the named pipe goes through a simple string based protocol

<pre>
11619 connect(6, {sa_family=AF_FILE, path="/tmp/.java_pid10015"}, 110) = 0
11619 write(6, "1", 1)                  = 1
11619 write(6, "\0", 1)                 = 1
11619 write(6, "threaddump", 10)        = 10
11619 write(6, "\0", 1)                 = 1
11619 write(6, "-l", 2)                 = 2
11619 write(6, "\0", 1)                 = 1
11619 write(6, "\0", 1)                 = 1
11619 write(6, "\0", 1)                 = 1

...

11619 read(6, "0", 1)                   = 1
11619 read(6, "\n", 1)                  = 1
11619 read(6, "2011-08-28 11:17:49\nFull thread "..., 128) = 128
11619 write(1, "2011-08-28 11:17:49\nFull thread "..., 128) = 128
11619 read(6, "95e5400 nid=0x2aef waiting on co"..., 128) = 128
11619 write(1, "95e5400 nid=0x2aef waiting on co"..., 128) = 128
11619 read(6, "ne\n\n\"DestroyJavaVM\" prio=10 tid="..., 128) = 128
11619 write(1, "ne\n\n\"DestroyJavaVM\" prio=10 tid="..., 128) = 128
11619 read(6, "Locked ownable synchronizers:\n\t-"..., 128) = 128
11619 write(1, "Locked ownable synchronizers:\n\t-"..., 128) = 128
11619 read(6, "va.lang.Thread.State: TIMED_WAIT"..., 128) = 128
11619 write(1, "va.lang.Thread.State: TIMED_WAIT"..., 128) = 128
11619 read(6, "va.util.concurrent.locks.Abstrac"..., 128) = 128
</pre>

Aha, so jstack just sends a string command to the traced JVM, and the JVM returns all report lines over the named pipe's socket.


So while the program is running, we can look at the named pipe

<pre>
stat /tmp/.java_pid10015

Size: 0               Blocks: 0          IO Block: 4096   socket
Device: fd00h/64768d    Inode: 14699683    Links: 1
Access: (0600/srw-------)  Uid: (  315/  mmoser)   Gid: (  231/     sps)
Access: 2011-08-28 11:17:07.000000000 +0300
Modify: 2011-08-28 11:13:20.000000000 +0300
Change: 2011-08-28 11:13:20.000000000 +0300
</pre>

The access permissions say that only the current process can access the named pipe, so be it.

h3. A script to automate usage of jstack

All this can be obtained from system information, just by knowing the process id number.
- We can see who is running the process, the permissions of the /proc/<pid>/ directory say so (the linux operating system maintains this directory per running process )
- The /proc/<pid>/maps includes all shared memory ranges used by the process, so each shared library has it's text/code segment here + full path of the executable that is mapped in.'
     Each Hotspot java process loads a library called libjvm.so - so by finding the path name of libjvm.so we can infer the path of the used JDK version.

The script that can do all this "is here":https://github.com/MoserMichael/cstuff/blob/master/scripts/jstack/do-jstack	

A similar script "runs jstack at fixed time intervals":https://github.com/MoserMichael/cstuff/blob/master/scripts/jstack/do-jstack-loop , this can be used to track locking problems, etc. etc.


